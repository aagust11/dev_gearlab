// Generated by CoffeeScript 1.6.3
(function() {
  "use strict";
  var ArcSegment, LineSegment, Point, Util,
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; },
    __hasProp = {}.hasOwnProperty,
    __slice = [].slice;

  window.gearlab = {};

  Point = (function() {
    function Point(x, y) {
      this.x = x;
      this.y = y;
    }

    Point.prototype.plus = function(p) {
      return new Point(this.x + p.x, this.y + p.y);
    };

    Point.prototype.minus = function(p) {
      return new Point(this.x - p.x, this.y - p.y);
    };

    Point.prototype.times = function(n) {
      return new Point(n * this.x, n * this.y);
    };

    Point.prototype.distance = function(p) {
      return Math.sqrt(Math.pow(this.x - p.x, 2) + Math.pow(this.y - p.y, 2));
    };

    Point.prototype.cross = function(p) {
      return this.x * p.y - this.y * p.x;
    };

    Point.prototype.clone = function() {
      return new Point(this.x, this.y);
    };

    Point.polar = function(theta, r) {
      return new Point(r * Math.cos(theta), r * Math.sin(theta));
    };

    Point.fromObject = function(obj) {
      return new Point(obj.x, obj.y);
    };

    return Point;

  })();

  window.gearlab.Point = Point;

  ArcSegment = (function() {
    function ArcSegment(center, radius, startAngle, endAngle, direction) {
      this.center = center;
      this.radius = radius;
      this.startAngle = startAngle;
      this.endAngle = endAngle;
      this.direction = direction;
      this.start = this.pointOnCircle(startAngle);
      this.end = this.pointOnCircle(endAngle);
    }

    ArcSegment.prototype.getLength = function() {
      var angle;
      angle = this.direction === Util.Direction.CLOCKWISE ? Util.mod(this.endAngle - this.startAngle, 2 * Math.PI) : Util.mod(this.startAngle - this.endAngle, 2 * Math.PI);
      return angle * this.radius;
    };

    ArcSegment.prototype.findPoint = function(distanceToGo) {
      var angle, angleToGo;
      angleToGo = distanceToGo / this.radius;
      angle = this.startAngle + (this.direction === Util.Direction.CLOCKWISE ? angleToGo : -angleToGo);
      return this.center.plus(Point.polar(angle, this.radius));
    };

    ArcSegment.prototype.pointOnCircle = function(angle) {
      return this.center.plus(Point.polar(angle, this.radius));
    };

    ArcSegment.prototype.containsAngle = function(angle) {
      if (this.direction === Util.Direction.CLOCKWISE) {
        return Util.mod(this.endAngle - this.startAngle, 2 * Math.PI) > Util.mod(angle - this.startAngle, 2 * Math.PI);
      } else {
        return Util.mod(this.startAngle - this.endAngle, 2 * Math.PI) > Util.mod(this.startAngle - angle, 2 * Math.PI);
      }
    };

    ArcSegment.prototype.distanceToPoint = function(point) {
      var angle;
      angle = Math.atan2(point.y - this.center.y, point.x - this.center.x);
      if (this.containsAngle(angle)) {
        return Math.abs(point.distance(this.center) - this.radius);
      } else {
        return Math.min(point.distance(this.start), point.distance(this.end));
      }
    };

    ArcSegment.prototype.intersectsLineSegment = function(lineSegment) {
      var d, discriminant, dr, dx, dy, i1, i1x, i1y, i2, i2x, i2y, p1, p2;
      p1 = lineSegment.start.minus(this.center);
      p2 = lineSegment.end.minus(this.center);
      dx = p2.x - p1.x;
      dy = p2.y - p1.y;
      dr = Math.sqrt(Math.pow(dx, 2) + Math.pow(dy, 2));
      if (dr === 0) {
        return false;
      }
      d = p1.x * p2.y - p2.x * p1.y;
      discriminant = Math.pow(this.radius, 2) * Math.pow(dr, 2) - Math.pow(d, 2);
      if (discriminant < 0) {
        return false;
      } else {
        i1x = (d * dy + Util.sign(dy) * dx * Math.sqrt(discriminant)) / Math.pow(dr, 2);
        i1y = (-d * dx + Math.abs(dy) * Math.sqrt(discriminant)) / Math.pow(dr, 2);
        i1 = new Point(i1x, i1y).plus(this.center);
        if (lineSegment.distanceToPoint(i1) < Util.EPSILON && this.distanceToPoint(i1) < Util.EPSILON) {
          return true;
        }
        i2x = (d * dy - Util.sign(dy) * dx * Math.sqrt(discriminant)) / Math.pow(dr, 2);
        i2y = (-d * dx - Math.abs(dy) * Math.sqrt(discriminant)) / Math.pow(dr, 2);
        i2 = new Point(i2x, i2y).plus(this.center);
        if (lineSegment.distanceToPoint(i2) < Util.EPSILON && this.distanceToPoint(i2) < Util.EPSILON) {
          return true;
        }
        return false;
      }
    };

    ArcSegment.prototype.distanceToSegment = function(segment) {
      var angle1, angle2, centerDistance, pointNearestToCenter;
      if (segment instanceof ArcSegment) {
        if (this.center.distance(segment.center) > Util.EPSILON) {
          angle1 = Math.atan2(segment.center.y - this.center.y, segment.center.x - this.center.x);
          angle2 = Util.mod(angle1 + Math.PI, 2 * Math.PI);
          if (this.containsAngle(angle1) && segment.containsAngle(angle2)) {
            centerDistance = this.center.distance(segment.center);
            return Math.max(0, centerDistance - this.radius - segment.radius);
          }
        }
        return Math.min(this.distanceToPoint(segment.start), this.distanceToPoint(segment.end), segment.distanceToPoint(this.start), segment.distanceToPoint(this.end));
      } else {
        if (this.intersectsLineSegment(segment)) {
          return 0;
        } else {
          pointNearestToCenter = segment.findNearestPoint(this.center);
          return Math.min(this.distanceToPoint(pointNearestToCenter), this.distanceToPoint(segment.start), this.distanceToPoint(segment.end), segment.distanceToPoint(this.start), segment.distanceToPoint(this.end));
        }
      }
    };

    ArcSegment.prototype.clone = function() {
      return new ArcSegment(this.center.clone(), this.radius, this.startAngle, this.endAngle, this.direction);
    };

    ArcSegment.fromObject = function(obj) {
      return new ArcSegment(Point.fromObject(obj.center), obj.radius, obj.startAngle, obj.endAngle, obj.direction);
    };

    return ArcSegment;

  })();

  window.gearlab.ArcSegment = ArcSegment;

  LineSegment = (function() {
    function LineSegment(start, end) {
      this.start = start;
      this.end = end;
    }

    LineSegment.prototype.getLength = function() {
      return this.start.distance(this.end);
    };

    LineSegment.prototype.findPoint = function(distanceToGo) {
      var fraction;
      fraction = distanceToGo / this.start.distance(this.end);
      return this.start.plus(this.end.minus(this.start).times(fraction));
    };

    LineSegment.prototype.findNearestPoint = function(p) {
      var segmentLength, t;
      segmentLength = this.getLength();
      if (segmentLength === 0) {
        return this.start;
      } else {
        t = ((p.x - this.start.x) * (this.end.x - this.start.x) + (p.y - this.start.y) * (this.end.y - this.start.y)) / Math.pow(segmentLength, 2);
        if (t < 0) {
          return this.start;
        } else if (t > 1) {
          return this.end;
        } else {
          return this.start.plus(this.end.minus(this.start).times(t));
        }
      }
    };

    LineSegment.prototype.distanceToPoint = function(point) {
      return point.distance(this.findNearestPoint(point));
    };

    LineSegment.prototype.findIntersection = function(lineSegment) {
      var crossRS, p, q, r, s, t, u;
      p = this.start;
      r = this.end.minus(p);
      q = lineSegment.start;
      s = lineSegment.end.minus(q);
      crossRS = r.cross(s);
      t = q.minus(p).cross(s) / crossRS;
      u = q.minus(p).cross(r) / crossRS;
      if (Math.abs(crossRS) > Util.EPSILON && 0 <= t && t <= 1 && 0 <= u && u <= 1) {
        return p.plus(r.times(t));
      } else {
        return null;
      }
    };

    LineSegment.prototype.distanceToSegment = function(segment) {
      if (segment instanceof LineSegment) {
        if (this.findIntersection(segment)) {
          return 0;
        } else {
          return Math.min(this.distanceToPoint(segment.start), this.distanceToPoint(segment.end), segment.distanceToPoint(this.start), segment.distanceToPoint(this.end));
        }
      } else {
        return segment.distanceToSegment(this);
      }
    };

    LineSegment.prototype.clone = function() {
      return new LineSegment(this.start.clone(), this.end.clone());
    };

    LineSegment.fromObject = function(obj) {
      return new LineSegment(Point.fromObject(obj.start), Point.fromObject(obj.end));
    };

    return LineSegment;

  })();

  window.gearlab.LineSegment = LineSegment;

  Util = (function() {
    function Util() {}

    Point = window.gearlab.Point;

    Util.MODULE = 6;

    Util.AXIS_RADIUS = 1.5 * Util.MODULE;

    Util.MIN_STACKED_GEARS_TEETH_DIFFERENCE = 4;

    Util.SNAPPING_DISTANCE = 2 * Util.MODULE;

    Util.EPSILON = 0.000001;

    Util.Direction = {
      CLOCKWISE: "clockwise",
      COUNTER_CLOCKWISE: "counterclockwise"
    };

    Util.Side = {
      LEFT: "left",
      RIGHT: "right"
    };

    Util.clone = function(obj) {
      var copy, i, key, knownClasses, _i, _ref, _ref1;
      if ((obj == null) || (typeof obj !== "object")) {
        return obj;
      }
      knownClasses = ["Point", "Gear", "ArcSegment", "LineSegment", "Chain"];
      if (_ref = obj.constructor.name, __indexOf.call(knownClasses, _ref) >= 0) {
        return obj.clone();
      }
      if (obj instanceof Array) {
        copy = [];
        for (i = _i = 0, _ref1 = obj.length; 0 <= _ref1 ? _i < _ref1 : _i > _ref1; i = 0 <= _ref1 ? ++_i : --_i) {
          copy[i] = this.clone(obj[i]);
        }
        return copy;
      }
      if (obj instanceof Object) {
        copy = {};
        for (key in obj) {
          if (!__hasProp.call(obj, key)) continue;
          copy[key] = this.clone(obj[key]);
        }
        return copy;
      }
      throw new Error("Unable to clone object. Its type is not supported.");
    };

    Util.createUUID = function() {
      return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, function(c) {
        var r, v;
        r = Math.random() * 16 | 0;
        v = c === "x" ? r : r & 0x3 | 0x8;
        return v.toString(16);
      });
    };

    Util.mod = function(a, b) {
      return (a % b + b) % b;
    };

    Util.sign = function(x) {
      if (x < 0) {
        return -1;
      } else {
        return 1;
      }
    };

    Util.addAll = function(set, elements) {
      var element, _i, _len;
      for (_i = 0, _len = elements.length; _i < _len; _i++) {
        element = elements[_i];
        set[element] = true;
      }
      return set;
    };

    Util.makeSetFromList = function(elements) {
      return this.addAll({}, elements);
    };

    Util.makeSet = function() {
      var elements;
      elements = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      return this.makeSetFromList(elements);
    };

    Util.findPointOnPath = function(path, distance) {
      var distanceToGo, i, j, numberOfPoints, segment, segmentLength;
      distanceToGo = distance;
      i = 0;
      numberOfPoints = path.length;
      while (distanceToGo > 0) {
        j = (i + 1) % numberOfPoints;
        segment = new LineSegment(path[i], path[j]);
        segmentLength = segment.getLength();
        if (distanceToGo <= segmentLength) {
          return segment.findPoint(distanceToGo);
        } else {
          i = j;
          distanceToGo -= segmentLength;
        }
      }
      return null;
    };

    Util.getLength = function(path, isPathClosed) {
      var finalIndex, i, j, length, numberOfPoints, _i;
      if (isPathClosed == null) {
        isPathClosed = true;
      }
      length = 0;
      numberOfPoints = path.length;
      finalIndex = numberOfPoints - (isPathClosed ? 0 : 1);
      for (i = _i = 0; 0 <= finalIndex ? _i < finalIndex : _i > finalIndex; i = 0 <= finalIndex ? ++_i : --_i) {
        j = (i + 1) % numberOfPoints;
        length += path[i].distance(path[j]);
      }
      return length;
    };

    Util.isPointInsidePolygon = function(point, polygon) {
      var i, isPointInPolygon, j, numberOfVertices, pix, piy, pjx, pjy, x, y, _i;
      isPointInPolygon = false;
      x = point.x;
      y = point.y;
      numberOfVertices = polygon.length;
      j = numberOfVertices - 1;
      for (i = _i = 0; 0 <= numberOfVertices ? _i < numberOfVertices : _i > numberOfVertices; i = 0 <= numberOfVertices ? ++_i : --_i) {
        pix = polygon[i].x;
        piy = polygon[i].y;
        pjx = polygon[j].x;
        pjy = polygon[j].y;
        if (((piy > y) !== (pjy > y)) && (x < ((pjx - pix) * (y - piy) / (pjy - piy) + pix))) {
          isPointInPolygon = !isPointInPolygon;
        }
        j = i;
      }
      return isPointInPolygon;
    };

    Util.isGearInsidePolygon = function(gear, polygon) {
      var edgePointAtAngle, edgePoints, i,
        _this = this;
      edgePointAtAngle = function(angle) {
        return gear.location.plus(Point.polar(angle, gear.innerRadius));
      };
      edgePoints = (function() {
        var _i, _results;
        _results = [];
        for (i = _i = 0; _i < 8; i = ++_i) {
          _results.push(edgePointAtAngle(0.25 * Math.PI * i));
        }
        return _results;
      })();
      return edgePoints.every(function(p) {
        return _this.isPointInsidePolygon(p, polygon);
      });
    };

    Util.findGearsInsidePolygon = function(polygon, gears) {
      var gear, id, _results;
      _results = [];
      for (id in gears) {
        if (!__hasProp.call(gears, id)) continue;
        gear = gears[id];
        if (this.isGearInsidePolygon(gear, polygon)) {
          _results.push(gear);
        }
      }
      return _results;
    };

    Util.doesGearIntersectLineSegment = function(gear, segment) {
      return segment.distanceToPoint(gear.location) < (gear.pitchRadius + Util.EPSILON);
    };

    Util.findGearsIntersectingSegment = function(gears, segment) {
      var gear, id, _results;
      _results = [];
      for (id in gears) {
        if (!__hasProp.call(gears, id)) continue;
        gear = gears[id];
        if (this.doesGearIntersectLineSegment(gear, segment)) {
          _results.push(gear);
        }
      }
      return _results;
    };

    Util.pointPathDistance = function(point, path, isPathClosed) {
      var d, distance, finalIndex, i, j, numberOfPoints, segment, _i;
      if (isPathClosed == null) {
        isPathClosed = true;
      }
      distance = Number.MAX_VALUE;
      numberOfPoints = path.length;
      finalIndex = numberOfPoints - (isPathClosed ? 0 : 1);
      for (i = _i = 0; 0 <= finalIndex ? _i < finalIndex : _i > finalIndex; i = 0 <= finalIndex ? ++_i : --_i) {
        j = (i + 1) % numberOfPoints;
        segment = new LineSegment(path[i], path[j]);
        d = Math.max(0, segment.distanceToPoint(point));
        distance = Math.min(distance, d);
      }
      return distance;
    };

    Util.findNearestIntersectingGear = function(gears, lineSegment, ignoredGearIds) {
      var intersectingGear, intersectingGears, _i, _len,
        _this = this;
      if (ignoredGearIds == null) {
        ignoredGearIds = {};
      }
      intersectingGears = this.findGearsIntersectingSegment(gears, lineSegment);
      intersectingGears.sort(function(g1, g2) {
        return g1.distanceToPoint(lineSegment.start) - g2.distanceToPoint(lineSegment.start);
      });
      for (_i = 0, _len = intersectingGears.length; _i < _len; _i++) {
        intersectingGear = intersectingGears[_i];
        if (!(intersectingGear.id in ignoredGearIds)) {
          return intersectingGear;
        }
      }
      return null;
    };

    Util.findDirection = function(polygon) {
      var doubleArea, i, j, numberOfPoints, _i;
      numberOfPoints = polygon.length;
      doubleArea = 0;
      for (i = _i = 0; 0 <= numberOfPoints ? _i < numberOfPoints : _i > numberOfPoints; i = 0 <= numberOfPoints ? ++_i : --_i) {
        j = (i + 1) % numberOfPoints;
        doubleArea += polygon[i].x * polygon[j].y;
        doubleArea -= polygon[i].y * polygon[j].x;
      }
      if (doubleArea > 0) {
        return this.Direction.CLOCKWISE;
      } else {
        return this.Direction.COUNTER_CLOCKWISE;
      }
    };

    Util.findTangentPoints = function(p, c, r) {
      var alpha, beta, d, l, tangentPoints;
      tangentPoints = {};
      d = p.distance(c);
      if (Math.abs(d - r) < Util.EPSILON) {
        tangentPoints[this.Side.RIGHT] = p.clone();
        tangentPoints[this.Side.LEFT] = p.clone();
      } else {
        l = Math.sqrt(d * d - r * r);
        alpha = Math.atan2(c.y - p.y, c.x - p.x);
        beta = Math.asin(r / d);
        tangentPoints[this.Side.RIGHT] = p.plus(Point.polar(alpha + beta, l));
        tangentPoints[this.Side.LEFT] = p.plus(Point.polar(alpha - beta, l));
      }
      return tangentPoints;
    };

    Util.findGearTangentPoints = function(p, gear) {
      return this.findTangentPoints(p, gear.location, gear.pitchRadius);
    };

    Util.findExternalTangents = function(centers, radii) {
      var angle, largest, o1, o2, offset1, offset2, r1, r2, r3, ratio, tangentLine1, tangentLine2, tangentLines, tangentPoints, tpl, tpr;
      largest = radii[0] >= radii[1] ? 0 : 1;
      o1 = centers[largest];
      o2 = centers[1 - largest];
      r1 = radii[largest];
      r2 = radii[1 - largest];
      r3 = r1 - r2;
      if (r3 === 0) {
        tangentPoints = {};
        tangentPoints[this.Side.LEFT] = o1;
        tangentPoints[this.Side.RIGHT] = o1;
        angle = Math.atan2(o2.y - o1.y, o2.x - o1.x);
        offset1 = Point.polar(angle + 0.5 * Math.PI, r1);
        offset2 = Point.polar(angle - 0.5 * Math.PI, r1);
      } else {
        tangentPoints = this.findTangentPoints(o2, o1, r3);
        ratio = r2 / r3;
        tpl = tangentPoints[this.Side.LEFT];
        tpr = tangentPoints[this.Side.RIGHT];
        offset1 = tpl.minus(o1).times(ratio);
        offset2 = tpr.minus(o1).times(ratio);
      }
      tangentLine1 = [tangentPoints[this.Side.LEFT].plus(offset1), o2.plus(offset1)];
      tangentLine2 = [tangentPoints[this.Side.RIGHT].plus(offset2), o2.plus(offset2)];
      tangentLines = {};
      if (o1 === centers[0]) {
        tangentLines[this.Side.RIGHT] = new LineSegment(tangentLine1[0], tangentLine1[1]);
        tangentLines[this.Side.LEFT] = new LineSegment(tangentLine2[0], tangentLine2[1]);
      } else {
        tangentLines[this.Side.RIGHT] = new LineSegment(tangentLine2[1], tangentLine2[0]);
        tangentLines[this.Side.LEFT] = new LineSegment(tangentLine1[1], tangentLine1[0]);
      }
      return tangentLines;
    };

    Util.findInternalTangents = function(centers, radii) {
      var largest, o1, o2, offset1, offset2, r1, r2, r3, ratio, tangentLine1, tangentLine2, tangentLines, tangentPoints, tpl, tpr;
      largest = radii[0] >= radii[1] ? 0 : 1;
      o1 = centers[largest];
      o2 = centers[1 - largest];
      r1 = radii[largest];
      r2 = radii[1 - largest];
      r3 = r1 + r2;
      tangentPoints = this.findTangentPoints(o2, o1, r3);
      ratio = r2 / r3;
      tpl = tangentPoints[this.Side.LEFT];
      tpr = tangentPoints[this.Side.RIGHT];
      offset1 = o1.minus(tpl).times(ratio);
      offset2 = o1.minus(tpr).times(ratio);
      tangentLine1 = [tpl.plus(offset1), o2.plus(offset1)];
      tangentLine2 = [tpr.plus(offset2), o2.plus(offset2)];
      tangentLines = {};
      if (o1 === centers[0]) {
        tangentLines[this.Side.RIGHT] = new LineSegment(tangentLine1[0], tangentLine1[1]);
        tangentLines[this.Side.LEFT] = new LineSegment(tangentLine2[0], tangentLine2[1]);
      } else {
        tangentLines[this.Side.RIGHT] = new LineSegment(tangentLine1[1], tangentLine1[0]);
        tangentLines[this.Side.LEFT] = new LineSegment(tangentLine2[1], tangentLine2[0]);
      }
      return tangentLines;
    };

    Util.findExternalTangentsOfGears = function(gear1, gear2) {
      return this.findExternalTangents([gear1.location, gear2.location], [gear1.pitchRadius, gear2.pitchRadius]);
    };

    Util.findInternalTangentsOfGears = function(gear1, gear2) {
      return this.findInternalTangents([gear1.location, gear2.location], [gear1.pitchRadius, gear2.pitchRadius]);
    };

    Util.findTangentLine = function(gear1, gear2, innerGearIds, direction) {
      var gear1isInnerGear, side;
      gear1isInnerGear = gear1.id in innerGearIds;
      if (gear1isInnerGear === (direction === this.Direction.CLOCKWISE)) {
        side = this.Side.LEFT;
      } else {
        side = this.Side.RIGHT;
      }
      if (gear1isInnerGear === (gear2.id in innerGearIds)) {
        return this.findExternalTangentsOfGears(gear1, gear2)[side];
      } else {
        return this.findInternalTangentsOfGears(gear1, gear2)[side];
      }
    };

    Util.findAllSimplePathsForNodes = function(turningObjects, goalNode, nodesVisited) {
      var currentNode, neighbor, neighborId, paths, updatedNodesVisited, _ref;
      paths = [];
      currentNode = nodesVisited[nodesVisited.length - 1];
      _ref = currentNode.connections;
      for (neighborId in _ref) {
        if (!__hasProp.call(_ref, neighborId)) continue;
        neighbor = turningObjects[neighborId];
        if (__indexOf.call(nodesVisited, neighbor) < 0) {
          updatedNodesVisited = nodesVisited.slice(0);
          updatedNodesVisited.push(neighbor);
          if (neighbor === goalNode) {
            paths.push(updatedNodesVisited);
          } else {
            paths = paths.concat(this.findAllSimplePathsForNodes(turningObjects, goalNode, updatedNodesVisited));
          }
        }
      }
      return paths;
    };

    Util.findAllSimplePathsBetweenNeighbors = function(turningObjects) {
      var i, id, j, nodes, paths, turningObject, _i, _j, _k, _ref, _ref1, _ref2, _ref3;
      paths = [];
      nodes = (function() {
        var _results;
        _results = [];
        for (id in turningObjects) {
          if (!__hasProp.call(turningObjects, id)) continue;
          turningObject = turningObjects[id];
          _results.push(turningObject);
        }
        return _results;
      })();
      if (nodes.length < 2) {
        return [];
      }
      for (i = _i = 0, _ref = nodes.length - 1; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
        for (j = _j = _ref1 = i + 1, _ref2 = nodes.length; _ref1 <= _ref2 ? _j < _ref2 : _j > _ref2; j = _ref1 <= _ref2 ? ++_j : --_j) {
          if (nodes[i].connections[nodes[j].id] != null) {
            paths = paths.concat(this.findAllSimplePathsForNodes(turningObjects, nodes[j], [nodes[i]]));
          }
        }
      }
      for (i = _k = 0, _ref3 = paths.length; 0 <= _ref3 ? _k < _ref3 : _k > _ref3; i = 0 <= _ref3 ? ++_k : --_k) {
        paths.push(paths[i].slice(0).reverse());
      }
      return paths;
    };

    Util.sendGetRequest = function(url) {
      var request;
      request = new XMLHttpRequest();
      request.open("GET", url, false);
      request.send(null);
      return request.responseText;
    };

    Util.sendPostRequest = function(data, url, callback) {
      var request;
      request = new XMLHttpRequest();
      request.open("POST", url, true);
      request.setRequestHeader("Content-type", "application/json; charset=UTF-8");
      request.onload = callback;
      return request.send(data);
    };

    return Util;

  })();

  window.gearlab.Util = Util;

  (function() {
    var lastTime, vendor, vendors, _i, _len;
    lastTime = 0;
    vendors = ["ms", "moz", "webkit", "o"];
    for (_i = 0, _len = vendors.length; _i < _len; _i++) {
      vendor = vendors[_i];
      if (!(!window.requestAnimationFrame)) {
        continue;
      }
      window.requestAnimationFrame = window[vendor + "RequestAnimationFrame"];
      window.cancelAnimationFrame = window[vendor + "CancelAnimationFrame"] || window[vendor + "CancelRequestAnimationFrame"];
    }
    if (!window.requestAnimationFrame) {
      window.requestAnimationFrame = function(callback) {
        var currTime, id, timeToCall;
        currTime = new Date().getTime();
        timeToCall = Math.max(0, 16 - (currTime - lastTime));
        id = window.setTimeout((function() {
          return callback(currTime + timeToCall);
        }), timeToCall);
        lastTime = currTime + timeToCall;
        return id;
      };
    }
    if (!window.cancelAnimationFrame) {
      return window.cancelAnimationFrame = function(id) {
        return clearTimeout(id);
      };
    }
  })();

  (function() {
    if ((Function.prototype.name == null) && (Object.defineProperty != null)) {
      return Object.defineProperty(Function.prototype, "name", {
        get: function() {
          var funcNameRegex, results;
          funcNameRegex = /function\s([^(]{1,})\(/;
          results = funcNameRegex.exec(this.toString());
          if ((results != null) && results.length > 1) {
            return results[1].trim();
          } else {
            return "";
          }
        },
        set: function(value) {}
      });
    }
  })();

}).call(this);

/*
//@ sourceMappingURL=gearlab_util.map
*/
// Generated by CoffeeScript 1.6.3
(function() {
  "use strict";
  var ArcSegment, Board, Chain, Gear, LineSegment, Point, Util,
    __hasProp = {}.hasOwnProperty,
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  Point = window.gearlab.Point;

  ArcSegment = window.gearlab.ArcSegment;

  LineSegment = window.gearlab.LineSegment;

  Util = window.gearlab.Util;

  window.gearlab.model = {};

  Gear = (function() {
    function Gear(location, rotation, numberOfTeeth, id, momentum, group, level, connections, rpm, direction, isDriver) {
      this.location = location;
      this.rotation = rotation;
      this.numberOfTeeth = numberOfTeeth;
      this.id = id;
      this.momentum = momentum != null ? momentum : 0;
      this.group = group != null ? group : 0;
      this.level = level != null ? level : 0;
      this.connections = connections != null ? connections : {};
      if (this.id == null) {
        this.id = Util.createUUID();
      }
      this.direction = direction != null ? direction : (this.momentum >= 0 ? 1 : -1);
      this.rpm = rpm != null ? rpm : Math.abs(this.momentum) * 60 / (2 * Math.PI);
      this.isDriver = isDriver != null ? isDriver : this.momentum !== 0;
      this.updateDimensions();
      this.normalizeMotion();
    }

    Gear.prototype.normalizeMotion = function() {
      var radiansPerSecond;
      if (isNaN(this.rpm) || !isFinite(this.rpm)) {
        this.rpm = 0;
      }
      this.rpm = Math.round(this.rpm * 100) / 100;
      this.direction = this.direction === -1 ? -1 : 1;
      radiansPerSecond = this.rpm * 2 * Math.PI / 60;
      if (!isFinite(radiansPerSecond)) {
        radiansPerSecond = 0;
      }
      return this.momentum = radiansPerSecond * this.direction;
    };

    Gear.prototype.updateDimensions = function() {
      this.pitchRadius = Util.MODULE * (0.5 * this.numberOfTeeth);
      this.innerRadius = Util.MODULE * (0.5 * this.numberOfTeeth - 1.25);
      return this.outerRadius = Util.MODULE * (0.5 * this.numberOfTeeth + 1);
    };

    Gear.prototype.setNumberOfTeeth = function(numberOfTeeth) {
      this.numberOfTeeth = numberOfTeeth;
      return this.updateDimensions();
    };

    Gear.prototype.updateMotion = function(rpm, direction, isDriver) {
      if (rpm != null) {
        this.rpm = rpm;
      }
      if (direction != null) {
        this.direction = direction;
      }
      if (isDriver != null) {
        this.isDriver = isDriver;
      }
      return this.normalizeMotion();
    };

    Gear.prototype.getCircumference = function() {
      return 2 * Math.PI * this.pitchRadius;
    };

    Gear.prototype.distanceToPoint = function(point) {
      return Math.max(0, this.location.distance(point) - this.pitchRadius);
    };

    Gear.prototype.edgeDistance = function(gear) {
      var axisDistance;
      axisDistance = this.location.distance(gear.location);
      return Math.abs(axisDistance - this.pitchRadius - gear.pitchRadius);
    };

    Gear.prototype.restore = function(gear) {
      this.location = gear.location;
      this.rotation = gear.rotation;
      this.momentum = gear.momentum;
      this.rpm = gear.rpm;
      this.direction = gear.direction;
      this.isDriver = gear.isDriver;
      this.updateDimensions();
      this.group = gear.group;
      this.level = gear.level;
      this.connections = gear.connections;
      return this.normalizeMotion();
    };

    Gear.prototype.clone = function() {
      return new Gear(this.location.clone(), this.rotation, this.numberOfTeeth, this.id, this.momentum, this.group, this.level, Util.clone(this.connections), this.rpm, this.direction, this.isDriver);
    };

    Gear.fromObject = function(obj) {
      return new Gear(Point.fromObject(obj.location), obj.rotation, obj.numberOfTeeth, obj.id, obj.momentum, obj.group, obj.level, obj.connections, obj.rpm, obj.direction, obj.isDriver);
    };

    return Gear;

  })();

  window.gearlab.model.Gear = Gear;

  Chain = (function() {
    Chain.WIDTH = 8;

    Chain.prototype.points = [];

    Chain.prototype.segments = [];

    function Chain(stroke, id, group, level, connections) {
      this.id = id;
      this.group = group != null ? group : 0;
      this.level = level != null ? level : 0;
      this.connections = connections != null ? connections : {};
      if (this.id == null) {
        this.id = Util.createUUID();
      }
      this.points = Util.clone(stroke);
      this.rotation = 0;
    }

    Chain.prototype.getLength = function() {
      return this.segments.reduce((function(total, segment) {
        return total + segment.getLength();
      }), 0);
    };

    Chain.prototype.getCircumference = function() {
      return this.getLength();
    };

    Chain.prototype.getStartingPoint = function() {
      if (this.direction === Util.Direction.CLOCKWISE) {
        return this.rotation / (2 * Math.PI) * this.getLength();
      } else {
        return -this.rotation / (2 * Math.PI) * this.getLength();
      }
    };

    Chain.prototype.findPointOnChain = function(distance) {
      var distanceToGo, length, segment, segmentLength, _i, _len, _ref;
      length = this.getLength();
      distanceToGo = Util.mod(distance + this.getStartingPoint(), length);
      _ref = this.segments;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        segment = _ref[_i];
        segmentLength = segment.getLength();
        if (distanceToGo < segmentLength) {
          return segment.findPoint(distanceToGo);
        } else {
          distanceToGo -= segmentLength;
        }
      }
      return null;
    };

    Chain.prototype.findPointsOnChain = function(numberOfPoints) {
      var delta, p, _i, _results;
      delta = this.getLength() / numberOfPoints;
      _results = [];
      for (p = _i = 0; 0 <= numberOfPoints ? _i < numberOfPoints : _i > numberOfPoints; p = 0 <= numberOfPoints ? ++_i : --_i) {
        _results.push(this.findPointOnChain(p * delta));
      }
      return _results;
    };

    Chain.prototype.distanceToPoint = function(point) {
      var segment;
      return Math.min.apply(null, (function() {
        var _i, _len, _ref, _results;
        _ref = this.segments;
        _results = [];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          segment = _ref[_i];
          _results.push(segment.distanceToPoint(point));
        }
        return _results;
      }).call(this));
    };

    Chain.prototype.distanceToSegment = function(s) {
      var segment;
      return Math.min.apply(null, (function() {
        var _i, _len, _ref, _results;
        _ref = this.segments;
        _results = [];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          segment = _ref[_i];
          _results.push(segment.distanceToSegment(s));
        }
        return _results;
      }).call(this));
    };

    Chain.prototype.distanceToChain = function(chain) {
      var segment;
      return Math.min.apply(null, (function() {
        var _i, _len, _ref, _results;
        _ref = this.segments;
        _results = [];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          segment = _ref[_i];
          _results.push(chain.distanceToSegment(segment));
        }
        return _results;
      }).call(this));
    };

    Chain.prototype.intersectsPath = function(path) {
      var i, j, _i, _ref;
      for (i = _i = 0, _ref = path.length - 1; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
        j = i + 1;
        if (this.distanceToSegment(new LineSegment(path[i], path[j])) === 0) {
          return true;
        }
      }
      return false;
    };

    Chain.prototype.crossesNonSupportingGears = function(board) {
      var gear, id, _ref;
      _ref = board.getGears();
      for (id in _ref) {
        if (!__hasProp.call(_ref, id)) continue;
        gear = _ref[id];
        if (!(__indexOf.call(this.supportingGearIds, id) >= 0) && !(id in this.ignoredGearIds)) {
          if (this.distanceToPoint(gear.location) < gear.pitchRadius + Util.EPSILON) {
            return true;
          }
        }
      }
      return false;
    };

    Chain.prototype.findPointOnSupportingGear = function(gearIndex, incoming) {
      if (incoming) {
        return this.points[Util.mod(2 * gearIndex - 1, this.points.length)];
      } else {
        return this.points[2 * gearIndex];
      }
    };

    Chain.prototype.removeGear = function(gear, board) {
      var acknowledgedGears, afterIndex, beforeGear, beforeIndex, g, gears, index, numberOfGears, path, replacementGears;
      while ((index = this.supportingGearIds.indexOf(gear.id)) !== -1) {
        gears = board.getGearsWithIds(this.supportingGearIds);
        numberOfGears = gears.length;
        beforeIndex = Util.mod(index - 1, numberOfGears);
        beforeGear = gears[beforeIndex];
        afterIndex = Util.mod(index + 1, numberOfGears);
        acknowledgedGears = board.getAcknowledgedGears(this.ignoredGearIds);
        path = [this.findPointOnSupportingGear(index, true), this.findPointOnSupportingGear(index, false), this.findPointOnSupportingGear(afterIndex, true)];
        replacementGears = this.findSupportingGearsOnPath(acknowledgedGears, beforeGear, path, 0, false);
        gears.splice.apply(gears, [index, 1].concat(replacementGears));
        this.removeRepeatedGears(gears);
        this.supportingGearIds = (function() {
          var _i, _len, _results;
          _results = [];
          for (_i = 0, _len = gears.length; _i < _len; _i++) {
            g = gears[_i];
            _results.push(g.id);
          }
          return _results;
        })();
      }
      return this.update(board);
    };

    Chain.prototype.findChainTangentSide = function(gear) {
      if ((this.direction === Util.Direction.CLOCKWISE) === (gear.id in this.innerGearIds)) {
        return Util.Side.LEFT;
      } else {
        return Util.Side.RIGHT;
      }
    };

    Chain.prototype.findReverseChainTangentSide = function(gear) {
      if (this.findChainTangentSide(gear) === Util.Side.LEFT) {
        return Util.Side.RIGHT;
      } else {
        return Util.Side.LEFT;
      }
    };

    Chain.prototype.findFirstSupportingGearOnPath = function(path, gears) {
      var a, b, d, pathLength, stepSize, supportingGear;
      stepSize = 10;
      pathLength = Util.getLength(path);
      supportingGear = null;
      a = path[0];
      d = 0;
      while (d < pathLength && (supportingGear == null)) {
        d += stepSize;
        b = Util.findPointOnPath(path, d);
        supportingGear = Util.findNearestIntersectingGear(gears, new LineSegment(a, b));
      }
      return [supportingGear, d];
    };

    Chain.prototype.findSupportingGearsOnPath = function(gears, firstSupportingGear, path, startDistance, isClosed) {
      var a, b, d, lineSegment, nextSupportingGear, pathLength, stepSize, supportingGear, supportingGears, tangentPoint, tangentSide;
      if (startDistance == null) {
        startDistance = 0;
      }
      if (isClosed == null) {
        isClosed = true;
      }
      stepSize = 10;
      pathLength = Util.getLength(path, isClosed);
      supportingGear = firstSupportingGear;
      supportingGears = [];
      a = firstSupportingGear.location;
      d = startDistance;
      while (d < pathLength) {
        d += stepSize;
        b = Util.findPointOnPath(path, d);
        tangentSide = this.findReverseChainTangentSide(supportingGear);
        tangentPoint = Util.findGearTangentPoints(b, supportingGear)[tangentSide];
        if (tangentPoint != null) {
          a = tangentPoint;
        }
        lineSegment = new LineSegment(a, b);
        nextSupportingGear = Util.findNearestIntersectingGear(gears, lineSegment, Util.makeSet(supportingGear.id));
        if (nextSupportingGear != null) {
          supportingGear = nextSupportingGear;
          supportingGears.push(supportingGear);
        }
      }
      return supportingGears;
    };

    Chain.prototype.removeRepeatedGears = function(gearsList) {
      var g1, g2, i, j, numberOfGears, numberOfNoops;
      numberOfNoops = 0;
      i = 0;
      while (numberOfNoops < (numberOfGears = gearsList.length)) {
        j = (i + 1) % numberOfGears;
        g1 = gearsList[i];
        g2 = gearsList[j];
        if (g1 === g2) {
          gearsList.splice(j, 1);
          numberOfNoops = 0;
        } else {
          numberOfNoops++;
          i = (i + 1) % numberOfGears;
        }
      }
      return gearsList;
    };

    Chain.prototype.containsSuccessiveOverlappingGears = function(gearsList) {
      var g1, g2, i, j, numberOfGears, _i;
      numberOfGears = gearsList.length;
      for (i = _i = 0; 0 <= numberOfGears ? _i < numberOfGears : _i > numberOfGears; i = 0 <= numberOfGears ? ++_i : --_i) {
        j = (i + 1) % numberOfGears;
        g1 = gearsList[i];
        g2 = gearsList[j];
        if (g1.location.distance(g2.location) < (g1.outerRadius + g2.outerRadius)) {
          return true;
        }
      }
      return false;
    };

    Chain.prototype.findSupportingGearIds = function(gears) {
      var finalSegment, firstSupportingGear, gear, lastSupportingGear, nextSupportingGears, startDistance, supportingGears, tangentPoint, tangentSide, _i, _len, _ref, _ref1, _results;
      _ref = this.findFirstSupportingGearOnPath(this.points, gears), firstSupportingGear = _ref[0], startDistance = _ref[1];
      supportingGears = [firstSupportingGear];
      nextSupportingGears = this.findSupportingGearsOnPath(gears, firstSupportingGear, this.points, startDistance);
      supportingGears = supportingGears.concat(nextSupportingGears);
      tangentSide = this.findChainTangentSide(firstSupportingGear);
      tangentPoint = Util.findGearTangentPoints(this.points[0], firstSupportingGear)[tangentSide];
      if (tangentPoint != null) {
        finalSegment = [this.points[0], tangentPoint];
        lastSupportingGear = supportingGears[supportingGears.length - 1];
        nextSupportingGears = this.findSupportingGearsOnPath(gears, lastSupportingGear, finalSegment, 0, false);
        supportingGears = supportingGears.concat(nextSupportingGears);
      }
      _ref1 = this.removeRepeatedGears(supportingGears);
      _results = [];
      for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
        gear = _ref1[_i];
        _results.push(gear.id);
      }
      return _results;
    };

    Chain.prototype.findIgnoredGearIds = function(board) {
      var acknowledgedLevels, currentDistance, currentLevel, d, distance, gear, gears, group, id, ignoredGearIds, level, levels, minDistances, _ref;
      gears = board.getGears();
      minDistances = {};
      for (id in gears) {
        if (!__hasProp.call(gears, id)) continue;
        gear = gears[id];
        group = gear.group;
        level = gear.level;
        d = Util.pointPathDistance(gear.location, this.points) - gear.pitchRadius;
        if ((((_ref = minDistances[group]) != null ? _ref[level] : void 0) == null) || d < minDistances[group][level]) {
          if (minDistances[group] == null) {
            minDistances[group] = {};
          }
          minDistances[group][level] = d;
        }
      }
      acknowledgedLevels = {};
      for (group in minDistances) {
        if (!__hasProp.call(minDistances, group)) continue;
        levels = minDistances[group];
        for (level in levels) {
          if (!__hasProp.call(levels, level)) continue;
          distance = levels[level];
          currentLevel = acknowledgedLevels[group];
          if (currentLevel == null) {
            acknowledgedLevels[group] = parseInt(level, 10);
          } else if (distance > 0) {
            currentDistance = minDistances[group][currentLevel];
            if (currentDistance < 0 || distance < currentDistance) {
              acknowledgedLevels[group] = parseInt(level, 10);
            }
          }
        }
      }
      ignoredGearIds = {};
      for (id in gears) {
        if (!__hasProp.call(gears, id)) continue;
        gear = gears[id];
        if (acknowledgedLevels[gear.group] !== gear.level) {
          ignoredGearIds[id] = true;
        }
      }
      return ignoredGearIds;
    };

    Chain.prototype.findIgnoredGearIdsInTightenedChain = function(board) {
      var gear, gearId, group, groups, id, level, updatedIgnoredGearIds, _i, _len, _ref, _ref1;
      groups = {};
      _ref = this.supportingGearIds;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        gearId = _ref[_i];
        gear = board.getGearWithId(gearId);
        group = gear.group;
        level = gear.level;
        if (groups[group] == null) {
          groups[group] = {};
        }
        groups[group][level] = true;
      }
      updatedIgnoredGearIds = {};
      _ref1 = board.getGears();
      for (id in _ref1) {
        if (!__hasProp.call(_ref1, id)) continue;
        gear = _ref1[id];
        group = gear.group;
        level = gear.level;
        if ((groups[group] != null) && (groups[group][level] == null)) {
          updatedIgnoredGearIds[id] = true;
        }
      }
      return this.ignoredGearIds = updatedIgnoredGearIds;
    };

    Chain.prototype.toPolygon = function(segments) {
      var polygon, segment, _i, _len;
      if (segments == null) {
        segments = this.segments;
      }
      polygon = [];
      for (_i = 0, _len = segments.length; _i < _len; _i++) {
        segment = segments[_i];
        if (segment instanceof LineSegment) {
          polygon.push(segment.start);
        } else {
          polygon.push(segment.findPoint(0));
          polygon.push(segment.findPoint(0.5 * segment.getLength()));
        }
      }
      return polygon;
    };

    Chain.prototype.update = function(board, gears) {
      var acknowledgedGears, arcEnd, arcSegment, arcStart, chainPolygon, direction, g1, g2, g3, gear, gearId, i, id, intersection, j, k, lineSegment, lineSegment1, lineSegment2, middleSegment, numberOfGears, numberOfSegments, p0, p1, p2, path, replacementGears, s1, s2, tangentLine, tangentPointG1, tangentPointG3, tangentSideG1, tangentSideG3, updatedAcknowledgedGears, updatedIgnoredGearIds, updatedInnerGearIds, updatedPoints, updatedSegments, _i, _j, _k, _l, _ref, _ref1, _ref2;
      if (gears == null) {
        gears = board.getGearsWithIds(this.supportingGearIds);
      }
      if (gears.length < 2) {
        return false;
      }
      if (this.containsSuccessiveOverlappingGears(gears)) {
        return false;
      }
      updatedIgnoredGearIds = this.findIgnoredGearIdsInTightenedChain(board);
      acknowledgedGears = board.getAcknowledgedGears(updatedIgnoredGearIds);
      i = 0;
      while (i < (numberOfGears = gears.length)) {
        j = (i + 1) % numberOfGears;
        k = (i + 2) % numberOfGears;
        g1 = gears[i];
        g2 = gears[j];
        g3 = gears[k];
        lineSegment1 = Util.findTangentLine(g1, g2, this.innerGearIds, this.direction);
        lineSegment2 = Util.findTangentLine(g2, g3, this.innerGearIds, this.direction);
        intersection = lineSegment1.findIntersection(lineSegment2);
        if (intersection != null) {
          tangentSideG1 = this.findReverseChainTangentSide(g1);
          tangentPointG1 = Util.findGearTangentPoints(intersection, g1)[tangentSideG1];
          tangentSideG3 = this.findChainTangentSide(g3);
          tangentPointG3 = Util.findGearTangentPoints(intersection, g3)[tangentSideG3];
          path = [tangentPointG1, intersection, tangentPointG3];
          replacementGears = this.findSupportingGearsOnPath(acknowledgedGears, g1, path, 0, false);
          if (__indexOf.call(replacementGears, g2) >= 0) {
            return false;
          }
          gears.splice.apply(gears, [j, 1].concat(replacementGears));
          this.removeRepeatedGears(gears);
          return this.update(board, gears);
        }
        gear = Util.findNearestIntersectingGear(acknowledgedGears, lineSegment1, Util.makeSet(g1.id, g2.id));
        if (gear != null) {
          gears.splice(j, 0, gear);
          if (this.containsSuccessiveOverlappingGears(gears)) {
            return false;
          }
        }
        i++;
      }
      updatedPoints = [];
      for (i = _i = 0; 0 <= numberOfGears ? _i < numberOfGears : _i > numberOfGears; i = 0 <= numberOfGears ? ++_i : --_i) {
        j = (i + 1) % numberOfGears;
        g1 = gears[i];
        g2 = gears[j];
        tangentLine = Util.findTangentLine(g1, g2, this.innerGearIds, this.direction);
        updatedPoints.push(tangentLine.start, tangentLine.end);
      }
      updatedSegments = [];
      for (i = _j = 0; 0 <= numberOfGears ? _j < numberOfGears : _j > numberOfGears; i = 0 <= numberOfGears ? ++_j : --_j) {
        p0 = updatedPoints[2 * i];
        p1 = updatedPoints[2 * i + 1];
        p2 = updatedPoints[2 * ((i + 1) % numberOfGears)];
        gear = gears[(i + 1) % numberOfGears];
        lineSegment = new LineSegment(p0, p1);
        arcStart = Math.atan2(p1.y - gear.location.y, p1.x - gear.location.x);
        arcEnd = Math.atan2(p2.y - gear.location.y, p2.x - gear.location.x);
        direction = (this.direction === Util.Direction.CLOCKWISE) === (gear.id in this.innerGearIds) ? Util.Direction.CLOCKWISE : Util.Direction.COUNTER_CLOCKWISE;
        arcSegment = new ArcSegment(gear.location, gear.pitchRadius, arcStart, arcEnd, direction);
        updatedSegments.push(lineSegment, arcSegment);
      }
      numberOfSegments = updatedSegments.length;
      for (i = _k = 0, _ref = numberOfSegments - 2; 0 <= _ref ? _k < _ref : _k > _ref; i = 0 <= _ref ? ++_k : --_k) {
        for (j = _l = _ref1 = i + 2; _ref1 <= numberOfSegments ? _l < numberOfSegments : _l > numberOfSegments; j = _ref1 <= numberOfSegments ? ++_l : --_l) {
          if (i !== 0 || j !== numberOfSegments - 1) {
            s1 = updatedSegments[i];
            s2 = updatedSegments[j];
            if (s1.distanceToSegment(s2) < Chain.WIDTH) {
              if ((i + 2) === j) {
                middleSegment = updatedSegments[i + 1];
                if ((middleSegment instanceof ArcSegment) && (middleSegment.getLength() < 2 * Chain.WIDTH)) {
                  continue;
                }
              }
              if (((j + 2) % numberOfSegments) === i) {
                middleSegment = updatedSegments[(j + 1) % numberOfSegments];
                if ((middleSegment instanceof ArcSegment) && (middleSegment.getLength() < 2 * Chain.WIDTH)) {
                  continue;
                }
              }
              return false;
            }
          }
        }
      }
      updatedIgnoredGearIds = this.findIgnoredGearIdsInTightenedChain(board);
      updatedAcknowledgedGears = board.getAcknowledgedGears(updatedIgnoredGearIds);
      chainPolygon = this.toPolygon(updatedSegments);
      updatedInnerGearIds = {};
      for (id in updatedAcknowledgedGears) {
        if (!__hasProp.call(updatedAcknowledgedGears, id)) continue;
        gear = updatedAcknowledgedGears[id];
        if (Util.isPointInsidePolygon(gear.location, chainPolygon)) {
          updatedInnerGearIds[id] = true;
        }
      }
      _ref2 = this.innerGearIds;
      for (gearId in _ref2) {
        if (!__hasProp.call(_ref2, gearId)) continue;
        if (!(gearId in updatedInnerGearIds) && (__indexOf.call(this.supportingGearIds, gearId) >= 0)) {
          return false;
        }
      }
      this.points = updatedPoints;
      this.segments = updatedSegments;
      this.ignoredGearIds = updatedIgnoredGearIds;
      this.innerGearIds = updatedInnerGearIds;
      this.supportingGearIds = (function() {
        var _len, _m, _results;
        _results = [];
        for (_m = 0, _len = gears.length; _m < _len; _m++) {
          gear = gears[_m];
          _results.push(gear.id);
        }
        return _results;
      })();
      return true;
    };

    Chain.prototype.tighten = function(board) {
      var acknowledgedGears, gear;
      this.ignoredGearIds = this.findIgnoredGearIds(board);
      acknowledgedGears = board.getAcknowledgedGears(this.ignoredGearIds);
      this.innerGearIds = Util.makeSetFromList((function() {
        var _i, _len, _ref, _results;
        _ref = Util.findGearsInsidePolygon(this.points, acknowledgedGears);
        _results = [];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          gear = _ref[_i];
          _results.push(gear.id);
        }
        return _results;
      }).call(this));
      if (Object.keys(this.innerGearIds).length < 2) {
        return false;
      }
      this.direction = Util.findDirection(this.points);
      this.supportingGearIds = this.findSupportingGearIds(acknowledgedGears);
      return this.update(board);
    };

    Chain.prototype.clone = function() {
      var copy;
      copy = new Chain(this.points, this.id, this.group, this.level, Util.clone(this.connections));
      copy.segments = Util.clone(this.segments);
      copy.ignoredGearIds = Util.clone(this.ignoredGearIds);
      copy.innerGearIds = Util.clone(this.innerGearIds);
      copy.direction = this.direction;
      copy.supportingGearIds = Util.clone(this.supportingGearIds);
      return copy;
    };

    Chain.fromObject = function(obj) {
      var chain, createSegment, p, points, segment;
      createSegment = function(obj) {
        if (obj.center != null) {
          return ArcSegment.fromObject(obj);
        } else {
          return LineSegment.fromObject(obj);
        }
      };
      points = (function() {
        var _i, _len, _ref, _results;
        _ref = obj.points;
        _results = [];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          p = _ref[_i];
          _results.push(new Point(p.x, p.y));
        }
        return _results;
      })();
      chain = new Chain(points, obj.id, obj.group, obj.level, obj.connections);
      chain.segments = (function() {
        var _i, _len, _ref, _results;
        _ref = obj.segments;
        _results = [];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          segment = _ref[_i];
          _results.push(createSegment(segment));
        }
        return _results;
      })();
      chain.ignoredGearIds = obj.ignoredGearIds;
      chain.innerGearIds = obj.innerGearIds;
      chain.direction = obj.direction;
      chain.supportingGearIds = obj.supportingGearIds;
      return chain;
    };

    return Chain;

  })();

  window.gearlab.model.Chain = Chain;

  Board = (function() {
    var AXIS_RADIUS, ConnectionType, EPSILON, MIN_STACKED_GEARS_TEETH_DIFFERENCE, MODULE, SNAPPING_DISTANCE;

    MODULE = Util.MODULE;

    AXIS_RADIUS = Util.AXIS_RADIUS;

    MIN_STACKED_GEARS_TEETH_DIFFERENCE = Util.MIN_STACKED_GEARS_TEETH_DIFFERENCE;

    SNAPPING_DISTANCE = Util.SNAPPING_DISTANCE;

    EPSILON = Util.EPSILON;

    ConnectionType = {
      ANY: "any",
      MESHING: "meshing",
      AXIS: "axis",
      CHAIN_INSIDE: "chain_inside",
      CHAIN_OUTSIDE: "chain_outside"
    };

    function Board(gears, chains) {
      this.gears = gears != null ? gears : {};
      this.chains = chains != null ? chains : {};
      this.lastMaxRpm = 0;
    }

    Board.prototype.restore = function(board) {
      var gear, id, _ref;
      _ref = this.gears;
      for (id in _ref) {
        if (!__hasProp.call(_ref, id)) continue;
        gear = _ref[id];
        gear.restore(board.gears[id]);
      }
      this.chains = board.chains;
      return this.recalculateGearSpeeds();
    };

    Board.prototype.restoreAfterDemo = function(board) {
      this.gears = board.gears;
      this.chains = board.chains;
      return this.recalculateGearSpeeds();
    };

    Board.prototype.clear = function() {
      this.gears = {};
      this.chains = {};
      this.lastMaxRpm = 0;
      return this;
    };

    Board.prototype.getNextGroup = function() {
      var gear, id, nextGroup, _ref;
      nextGroup = 0;
      _ref = this.gears;
      for (id in _ref) {
        if (!__hasProp.call(_ref, id)) continue;
        gear = _ref[id];
        nextGroup = Math.max(nextGroup, gear.group + 1);
      }
      return nextGroup;
    };

    Board.prototype.getGears = function() {
      return this.gears;
    };

    Board.prototype.getGearList = function() {
      var gear, id, _ref, _results;
      _ref = this.gears;
      _results = [];
      for (id in _ref) {
        if (!__hasProp.call(_ref, id)) continue;
        gear = _ref[id];
        _results.push(gear);
      }
      return _results;
    };

    Board.prototype.getAcknowledgedGears = function(ignoredGearIds) {
      var acknowledgedGears, gear, id, _ref;
      acknowledgedGears = {};
      _ref = this.gears;
      for (id in _ref) {
        if (!__hasProp.call(_ref, id)) continue;
        gear = _ref[id];
        if (!(id in ignoredGearIds)) {
          acknowledgedGears[id] = gear;
        }
      }
      return acknowledgedGears;
    };

    Board.prototype.getLevelScore = function(gear) {
      return 1000 * gear.group + gear.level;
    };

    Board.prototype.getGearsSortedByGroupAndLevel = function(gears) {
      var _this = this;
      if (gears == null) {
        gears = this.getGearList();
      }
      return gears.sort(function(g1, g2) {
        return _this.getLevelScore(g1) - _this.getLevelScore(g2);
      });
    };

    Board.prototype.removeConnection = function(turningObject1, turningObject2) {
      delete turningObject1.connections[turningObject2.id];
      return delete turningObject2.connections[turningObject1.id];
    };

    Board.prototype.removeAllConnections = function(turningObject) {
      var neighbor, neighborId, _ref;
      _ref = turningObject.connections;
      for (neighborId in _ref) {
        if (!__hasProp.call(_ref, neighborId)) continue;
        neighbor = this.getTurningObjects()[neighborId];
        this.removeConnection(turningObject, neighbor);
      }
      return this.updateGroupsAndLevels();
    };

    Board.prototype.findNearestAxis = function(gear) {
      var candidate, distance, id, nearestAxis, shortestDistance, _ref;
      nearestAxis = null;
      shortestDistance = Number.MAX_VALUE;
      _ref = this.gears;
      for (id in _ref) {
        if (!__hasProp.call(_ref, id)) continue;
        candidate = _ref[id];
        if (candidate !== gear) {
          distance = gear.location.distance(candidate.location);
          if (!nearestAxis || distance < (shortestDistance - EPSILON) || (distance < (shortestDistance + EPSILON) && candidate.numberOfTeeth < nearestAxis.numberOfTeeth)) {
            nearestAxis = candidate;
            shortestDistance = distance;
          }
        }
      }
      return nearestAxis;
    };

    Board.prototype.updateGroupsAndLevelsFrom = function(turningObjectId, group, level, updatedGroups, updatedLevels) {
      var connectionType, connections, gear, neighbor, neighborId, sameLevelConnectionTypes, turningObject, _results;
      turningObject = this.getTurningObjects()[turningObjectId];
      updatedGroups[turningObjectId] = group;
      updatedLevels[turningObjectId] = level;
      connections = turningObject.connections;
      sameLevelConnectionTypes = [ConnectionType.MESHING, ConnectionType.CHAIN_INSIDE, ConnectionType.CHAIN_OUTSIDE];
      _results = [];
      for (neighborId in connections) {
        if (!__hasProp.call(connections, neighborId)) continue;
        connectionType = connections[neighborId];
        if (!(neighborId in updatedGroups)) {
          if (__indexOf.call(sameLevelConnectionTypes, connectionType) >= 0) {
            _results.push(this.updateGroupsAndLevelsFrom(neighborId, group, level, updatedGroups, updatedLevels));
          } else {
            gear = this.gears[turningObjectId];
            neighbor = this.gears[neighborId];
            if (gear.numberOfTeeth > neighbor.numberOfTeeth) {
              _results.push(this.updateGroupsAndLevelsFrom(neighborId, group, level + 1, updatedGroups, updatedLevels));
            } else {
              _results.push(this.updateGroupsAndLevelsFrom(neighborId, group, level - 1, updatedGroups, updatedLevels));
            }
          }
        } else {
          _results.push(void 0);
        }
      }
      return _results;
    };

    Board.prototype.updateGroupsAndLevels = function() {
      var group, id, turningObject, updatedGroups, updatedLevels, _ref, _ref1;
      updatedGroups = {};
      updatedLevels = {};
      group = 0;
      _ref = this.gears;
      for (id in _ref) {
        if (!__hasProp.call(_ref, id)) continue;
        if (!(id in updatedGroups)) {
          this.updateGroupsAndLevelsFrom(id, group, 0, updatedGroups, updatedLevels);
          group++;
        }
      }
      _ref1 = this.getTurningObjects();
      for (id in _ref1) {
        if (!__hasProp.call(_ref1, id)) continue;
        turningObject = _ref1[id];
        turningObject.group = updatedGroups[id];
        turningObject.level = updatedLevels[id];
      }
      return null;
    };

    Board.prototype.addConnection = function(turningObject1, turningObject2, connectionType) {
      turningObject1.connections[turningObject2.id] = connectionType;
      turningObject2.connections[turningObject1.id] = connectionType;
      return this.updateGroupsAndLevels();
    };

    Board.prototype.findMeshingNeighbors = function(gear) {
      var candidate, candidateId, meshingNeighbors, _ref;
      meshingNeighbors = [];
      _ref = this.gears;
      for (candidateId in _ref) {
        if (!__hasProp.call(_ref, candidateId)) continue;
        candidate = _ref[candidateId];
        if (candidate !== gear && gear.edgeDistance(candidate) < EPSILON) {
          if ((candidate.group !== gear.group) || (candidate.level === gear.level)) {
            meshingNeighbors.push(candidate);
          }
        }
      }
      return meshingNeighbors;
    };

    Board.prototype.findRelativeAlignment = function(gear1, gear2) {
      var angle1, angle2, p1, p2, phase1, phase2, phaseSum, r1, r2, shift1, shift2, toothAngle1, toothAngle2;
      p1 = gear1.location;
      r1 = gear1.rotation;
      p2 = gear2.location;
      r2 = gear2.rotation;
      angle1 = Math.atan2(p2.y - p1.y, p2.x - p1.x);
      angle2 = angle1 + Math.PI;
      shift1 = Util.mod(angle1 - r1, 2 * Math.PI);
      shift2 = Util.mod(angle2 - r2, 2 * Math.PI);
      toothAngle1 = (2 * Math.PI) / gear1.numberOfTeeth;
      toothAngle2 = (2 * Math.PI) / gear2.numberOfTeeth;
      phase1 = (shift1 % toothAngle1) / toothAngle1;
      phase2 = (shift2 % toothAngle2) / toothAngle2;
      phaseSum = (phase1 + phase2) % 1;
      return (phaseSum - 0.25) * toothAngle1;
    };

    Board.prototype.alignGearTeeth = function(rotatingGear, meshingGear) {
      return rotatingGear.rotation += this.findRelativeAlignment(rotatingGear, meshingGear);
    };

    Board.prototype.areMeshingGearsAligned = function(gear1, gear2) {
      return Math.abs(this.findRelativeAlignment(gear1, gear2)) < EPSILON;
    };

    Board.prototype.rotateTurningObjectsFrom = function(turningObject, angle, rotatedTurningObjectIds) {
      var connectionType, neighbor, neighborId, ratio, _ref, _results;
      if (!(turningObject.id in rotatedTurningObjectIds)) {
        turningObject.rotation = Util.mod(turningObject.rotation + angle, 2 * Math.PI);
        rotatedTurningObjectIds[turningObject.id] = true;
      }
      _ref = turningObject.connections;
      _results = [];
      for (neighborId in _ref) {
        if (!__hasProp.call(_ref, neighborId)) continue;
        connectionType = _ref[neighborId];
        neighbor = this.getTurningObjects()[neighborId];
        if (!(neighborId in rotatedTurningObjectIds)) {
          ratio = this.calculateRatio(turningObject, neighbor, connectionType);
          _results.push(this.rotateTurningObjectsFrom(neighbor, angle * ratio, rotatedTurningObjectIds));
        } else {
          _results.push(void 0);
        }
      }
      return _results;
    };

    Board.prototype.alignMeshingGears = function(gear) {
      var angle, neighbor, neighbors, r, rotatedGearIds, _i, _len, _results;
      rotatedGearIds = {};
      rotatedGearIds[gear.id] = true;
      neighbors = this.findMeshingNeighbors(gear);
      _results = [];
      for (_i = 0, _len = neighbors.length; _i < _len; _i++) {
        neighbor = neighbors[_i];
        this.addConnection(gear, neighbor, ConnectionType.MESHING);
        angle = this.findRelativeAlignment(neighbor, gear);
        r = neighbor.rotation;
        this.alignGearTeeth(neighbor, gear);
        angle = neighbor.rotation - r;
        rotatedGearIds[neighbor.id] = true;
        _results.push(this.rotateTurningObjectsFrom(neighbor, angle, rotatedGearIds));
      }
      return _results;
    };

    Board.prototype.connectToAxis = function(upperGear, lowerGear) {
      this.addConnection(upperGear, lowerGear, ConnectionType.AXIS);
      upperGear.location = lowerGear.location.clone();
      upperGear.rotation = lowerGear.rotation;
      return this.alignMeshingGears(upperGear);
    };

    Board.prototype.findNearestNeighbor = function(gear, gearIdsToIgnore) {
      var edgeDistance, nearestNeighbor, neighbor, neighborId, shortestEdgeDistance, _ref;
      if (gearIdsToIgnore == null) {
        gearIdsToIgnore = {};
      }
      nearestNeighbor = null;
      shortestEdgeDistance = Number.MAX_VALUE;
      _ref = this.gears;
      for (neighborId in _ref) {
        if (!__hasProp.call(_ref, neighborId)) continue;
        neighbor = _ref[neighborId];
        if (neighbor !== gear && !(neighborId in gearIdsToIgnore)) {
          edgeDistance = gear.edgeDistance(neighbor);
          if (edgeDistance < shortestEdgeDistance) {
            nearestNeighbor = neighbor;
            shortestEdgeDistance = edgeDistance;
          }
        }
      }
      return nearestNeighbor;
    };

    Board.prototype.connectToOneMeshingGear = function(gear, meshingGear) {
      var angle, delta;
      delta = gear.location.minus(meshingGear.location);
      angle = Math.atan2(delta.y, delta.x);
      gear.location = meshingGear.location.plus(Point.polar(angle, gear.pitchRadius + meshingGear.pitchRadius));
      this.alignGearTeeth(gear, meshingGear);
      return this.addConnection(gear, meshingGear, ConnectionType.MESHING);
    };

    Board.prototype.connectToTwoMeshingGears = function(gear, meshingGear1, meshingGear2) {
      var a, d, h, p0, p1, p2, p3_1, p3_2, p3x1, p3x2, p3y1, p3y2, r0, r1;
      p0 = meshingGear1.location;
      p1 = meshingGear2.location;
      r0 = meshingGear1.pitchRadius + gear.pitchRadius;
      r1 = meshingGear2.pitchRadius + gear.pitchRadius;
      d = p0.distance(p1);
      if (r0 + r1 < d || p0.distance(p1) < EPSILON) {
        if (gear.edgeDistance(meshingGear1) < gear.edgeDistance(meshingGear2)) {
          this.connectToOneMeshingGear(gear, meshingGear1);
          return;
        } else {
          this.connectToOneMeshingGear(gear, meshingGear2);
          return;
        }
      }
      a = (r0 * r0 - r1 * r1 + d * d) / (2 * d);
      h = Math.sqrt(r0 * r0 - a * a);
      p2 = p0.plus(p1.minus(p0).times(a / d));
      p3x1 = p2.x + h * (p1.y - p0.y) / d;
      p3y1 = p2.y - h * (p1.x - p0.x) / d;
      p3x2 = p2.x - h * (p1.y - p0.y) / d;
      p3y2 = p2.y + h * (p1.x - p0.x) / d;
      p3_1 = new Point(p3x1, p3y1);
      p3_2 = new Point(p3x2, p3y2);
      if (gear.location.distance(p3_1) < gear.location.distance(p3_2)) {
        gear.location = p3_1;
      } else {
        gear.location = p3_2;
      }
      return this.alignMeshingGears(gear);
    };

    Board.prototype.doChainsCrossNonSupportingGears = function() {
      var chain, id, _ref;
      _ref = this.chains;
      for (id in _ref) {
        if (!__hasProp.call(_ref, id)) continue;
        chain = _ref[id];
        if (chain.crossesNonSupportingGears(this)) {
          return true;
        }
      }
      return false;
    };

    Board.prototype.doChainsCrossEachOther = function(c1, c2) {
      if ((c1.group !== c2.group) || (c1.level === c2.level)) {
        if (c1.distanceToChain(c2) < Chain.WIDTH) {
          return true;
        }
      }
      return false;
    };

    Board.prototype.doesChainCrossAnyOtherChain = function(chain) {
      var chain2, id2, _ref;
      _ref = this.chains;
      for (id2 in _ref) {
        if (!__hasProp.call(_ref, id2)) continue;
        chain2 = _ref[id2];
        if (chain !== chain2) {
          if (this.doChainsCrossEachOther(chain, chain2)) {
            return true;
          }
        }
      }
      return false;
    };

    Board.prototype.doAnyChainsCrossEachOther = function() {
      var c1, c2, chain, chainList, i, id, j, numberOfChains, _i, _j, _ref, _ref1;
      chainList = (function() {
        var _ref, _results;
        _ref = this.chains;
        _results = [];
        for (id in _ref) {
          if (!__hasProp.call(_ref, id)) continue;
          chain = _ref[id];
          _results.push(chain);
        }
        return _results;
      }).call(this);
      numberOfChains = chainList.length;
      if (numberOfChains < 2) {
        return false;
      }
      for (i = _i = 0, _ref = numberOfChains - 1; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
        for (j = _j = _ref1 = i + 1; _ref1 <= numberOfChains ? _j < numberOfChains : _j > numberOfChains; j = _ref1 <= numberOfChains ? ++_j : --_j) {
          c1 = chainList[i];
          c2 = chainList[j];
          if (this.doChainsCrossEachOther(c1, c2)) {
            return true;
          }
        }
      }
      return false;
    };

    Board.prototype.areAllMeshingGearsAligned = function() {
      var g1, g2, gears, i, j, numberOfGears, _i, _j, _ref, _ref1;
      gears = this.getGearList();
      numberOfGears = gears.length;
      if (numberOfGears < 2) {
        return true;
      }
      for (i = _i = 0, _ref = numberOfGears - 1; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
        for (j = _j = _ref1 = i + 1; _ref1 <= numberOfGears ? _j < numberOfGears : _j > numberOfGears; j = _ref1 <= numberOfGears ? ++_j : --_j) {
          g1 = gears[i];
          g2 = gears[j];
          if (g1.connections[g2.id] === ConnectionType.MESHING) {
            if (!this.areMeshingGearsAligned(g1, g2)) {
              return false;
            }
          }
        }
      }
      return true;
    };

    Board.prototype.calculateRatio = function(turningObject1, turningObject2, connectionType) {
      if (connectionType === ConnectionType.AXIS) {
        return 1;
      } else if ((connectionType === ConnectionType.MESHING) || (connectionType === ConnectionType.CHAIN_OUTSIDE)) {
        return -turningObject1.getCircumference() / turningObject2.getCircumference();
      } else {
        return turningObject1.getCircumference() / turningObject2.getCircumference();
      }
    };

    Board.prototype.calculatePathRatio = function(path) {
      var connectionType, i, pathLength, ratio, turningObject1, turningObject2, _i, _ref;
      ratio = 1;
      pathLength = path.length;
      for (i = _i = 0, _ref = pathLength - 1; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
        turningObject1 = path[i];
        turningObject2 = path[i + 1];
        connectionType = turningObject1.connections[turningObject2.id];
        ratio *= this.calculateRatio(turningObject1, turningObject2, connectionType);
      }
      return ratio;
    };

    Board.prototype.areConnectionRatiosConsistent = function() {
      var path, pathName, paths, ratio, ratios, _i, _len;
      ratios = {};
      paths = Util.findAllSimplePathsBetweenNeighbors(this.getTurningObjects());
      for (_i = 0, _len = paths.length; _i < _len; _i++) {
        path = paths[_i];
        pathName = "" + path[0].id + "-" + path[path.length - 1].id;
        ratio = this.calculatePathRatio(path);
        if (ratios[pathName] == null) {
          ratios[pathName] = ratio;
        } else {
          if (Math.abs(ratios[pathName] - ratio) > EPSILON) {
            return false;
          }
        }
      }
      return true;
    };

    Board.prototype.isBoardValid = function() {
      var axisDistance, combinedOuterRadius, gear1, gear2, group1, group2, id1, id2, level1, level2, maxOuterRadius, _ref, _ref1;
      _ref = this.gears;
      for (id1 in _ref) {
        if (!__hasProp.call(_ref, id1)) continue;
        gear1 = _ref[id1];
        group1 = gear1.group;
        level1 = gear1.level;
        _ref1 = this.gears;
        for (id2 in _ref1) {
          if (!__hasProp.call(_ref1, id2)) continue;
          gear2 = _ref1[id2];
          if (gear1 !== gear2) {
            group2 = gear2.group;
            level2 = gear2.level;
            axisDistance = gear1.location.distance(gear2.location);
            maxOuterRadius = Math.max(gear1.outerRadius, gear2.outerRadius);
            combinedOuterRadius = gear1.outerRadius + gear2.outerRadius;
            if (axisDistance < EPSILON) {
              if ((group1 !== group2) || (level1 === level2)) {
                return false;
              }
            } else if (group1 === group2 && level1 === level2 && (gear1.connections[gear2.id] == null)) {
              if (axisDistance < combinedOuterRadius) {
                return false;
              }
            } else if (axisDistance < maxOuterRadius + AXIS_RADIUS) {
              return false;
            }
          }
        }
      }
      return !this.doChainsCrossNonSupportingGears() && !this.doAnyChainsCrossEachOther() && this.areAllMeshingGearsAligned() && this.areConnectionRatiosConsistent();
    };

    Board.prototype.placeGear = function(gear, location) {
      var chain, id, nearestAxis, neighbor1, neighbor2, oldBoard, _ref;
      oldBoard = this.clone();
      this.removeAllConnections(gear);
      gear.location = location.clone();
      nearestAxis = this.findNearestAxis(gear);
      if (nearestAxis && gear.location.distance(nearestAxis.location) < SNAPPING_DISTANCE && nearestAxis.numberOfTeeth - gear.numberOfTeeth > MIN_STACKED_GEARS_TEETH_DIFFERENCE) {
        this.connectToAxis(gear, nearestAxis);
      } else {
        neighbor1 = this.findNearestNeighbor(gear);
        if (neighbor1 && gear.edgeDistance(neighbor1) < SNAPPING_DISTANCE) {
          neighbor2 = this.findNearestNeighbor(gear, Util.makeSet(neighbor1.id));
          if (neighbor2 && gear.edgeDistance(neighbor2) < SNAPPING_DISTANCE) {
            this.connectToTwoMeshingGears(gear, neighbor1, neighbor2);
          } else {
            this.connectToOneMeshingGear(gear, neighbor1);
          }
        }
      }
      _ref = this.chains;
      for (id in _ref) {
        if (!__hasProp.call(_ref, id)) continue;
        chain = _ref[id];
        if (chain.update(this)) {
          this.updateChainConnections(chain);
        } else {
          this.restore(oldBoard);
          return false;
        }
      }
      if (this.isBoardValid()) {
        return true;
      } else {
        this.restore(oldBoard);
        return false;
      }
    };

    Board.prototype.addGearToChains = function(gear) {
      var chain, id, _ref, _results;
      _ref = this.chains;
      _results = [];
      for (id in _ref) {
        if (!__hasProp.call(_ref, id)) continue;
        chain = _ref[id];
        if (Util.isPointInsidePolygon(gear.location, chain.toPolygon())) {
          _results.push(chain.innerGearIds[gear.id] = true);
        } else {
          _results.push(void 0);
        }
      }
      return _results;
    };

    Board.prototype.removeGearFromChains = function(gear) {
      var chain, id, _ref, _results;
      _ref = this.chains;
      _results = [];
      for (id in _ref) {
        if (!__hasProp.call(_ref, id)) continue;
        chain = _ref[id];
        if (!chain.removeGear(gear, this) || this.doesChainCrossAnyOtherChain(chain)) {
          _results.push(this.removeChain(chain));
        } else {
          _results.push(this.updateChainConnections(chain));
        }
      }
      return _results;
    };

    Board.prototype.addGear = function(gear) {
      var oldBoard;
      oldBoard = this.clone();
      gear.group = this.getNextGroup();
      this.gears[gear.id] = gear;
      this.addGearToChains(gear);
      if (!this.placeGear(gear, gear.location)) {
        this.removeGear(gear);
        this.restore(oldBoard);
        return false;
      } else {
        this.recalculateGearSpeeds();
        return true;
      }
    };

    Board.prototype.removeGear = function(gear) {
      this.removeAllConnections(gear);
      delete this.gears[gear.id];
      this.removeGearFromChains(gear);
      return this.recalculateGearSpeeds();
    };

    Board.prototype.getGearAt = function(location, candidates) {
      var candidate, distance, gear, id;
      if (candidates == null) {
        candidates = this.gears;
      }
      gear = null;
      for (id in candidates) {
        if (!__hasProp.call(candidates, id)) continue;
        candidate = candidates[id];
        distance = location.distance(candidate.location);
        if (distance < candidate.outerRadius) {
          if (!gear || candidate.numberOfTeeth < gear.numberOfTeeth) {
            gear = candidate;
          }
        }
      }
      return gear;
    };

    Board.prototype.isTopLevelGear = function(gear) {
      var connectionType, id, _ref;
      _ref = gear.connections;
      for (id in _ref) {
        if (!__hasProp.call(_ref, id)) continue;
        connectionType = _ref[id];
        if (connectionType === ConnectionType.AXIS && this.gears[id].level > gear.level) {
          return false;
        }
      }
      return true;
    };

    Board.prototype.getTopLevelGears = function() {
      var gear, id, topLevelGears, _ref;
      topLevelGears = {};
      _ref = this.gears;
      for (id in _ref) {
        if (!__hasProp.call(_ref, id)) continue;
        gear = _ref[id];
        if (this.isTopLevelGear(gear)) {
          topLevelGears[id] = gear;
        }
      }
      return topLevelGears;
    };

    Board.prototype.getTopLevelGearAt = function(location) {
      return this.getGearAt(location, this.getTopLevelGears());
    };

    Board.prototype.getGearWithId = function(id) {
      return this.gears[id];
    };

    Board.prototype.getGearsWithIds = function(ids) {
      var id, _i, _len, _results;
      _results = [];
      for (_i = 0, _len = ids.length; _i < _len; _i++) {
        id = ids[_i];
        _results.push(this.gears[id]);
      }
      return _results;
    };

    Board.prototype.rotateAllTurningObjects = function(delta) {
      var angle, gear, id, _ref, _results;
      _ref = this.gears;
      _results = [];
      for (id in _ref) {
        if (!__hasProp.call(_ref, id)) continue;
        gear = _ref[id];
        if (gear.momentum) {
          angle = gear.momentum * (delta / 1000);
          _results.push(this.rotateTurningObjectsFrom(gear, angle, {}));
        } else {
          _results.push(void 0);
        }
      }
      return _results;
    };

    Board.prototype.recalculateGearSpeeds = function() {
      var angularVelocities, chainId, connectionType, currentId, currentVelocity, direction, gear, id, neighborConnections, neighborId, queue, ratio, radiansPerSecond, turningObject, turningObjects, visited, _ref, _ref1, _results;
      turningObjects = this.getTurningObjects();
      angularVelocities = {};
      queue = [];
      _ref = this.gears;
      for (id in _ref) {
        if (!__hasProp.call(_ref, id)) continue;
        gear = _ref[id];
        if (gear.isDriver && (gear.rpm != null)) {
          gear.updateMotion(gear.rpm, gear.direction, gear.isDriver);
          angularVelocities[id] = gear.momentum;
          queue.push(id);
        } else {
          if (!gear.isDriver) {
            gear.updateMotion(0, gear.direction, gear.isDriver);
          } else {
            gear.updateMotion(gear.rpm, gear.direction, gear.isDriver);
          }
          angularVelocities[id] = null;
        }
      }
      _ref1 = this.chains;
      for (chainId in _ref1) {
        if (!__hasProp.call(_ref1, chainId)) continue;
        angularVelocities[chainId] = null;
      }
      visited = {};
      while (queue.length > 0) {
        currentId = queue.shift();
        currentVelocity = angularVelocities[currentId];
        visited[currentId] = true;
        turningObject = turningObjects[currentId];
        if (!(turningObject != null) || currentVelocity == null) {
          continue;
        }
        neighborConnections = turningObject.connections;
        for (neighborId in neighborConnections) {
          if (!__hasProp.call(neighborConnections, neighborId)) continue;
          if (angularVelocities[neighborId] != null) {
            continue;
          }
          ratio = this.calculateRatio(turningObject, turningObjects[neighborId], neighborConnections[neighborId]);
          if (!(turningObjects[neighborId] != null)) {
            continue;
          }
          angularVelocities[neighborId] = currentVelocity * ratio;
          queue.push(neighborId);
        }
      }
      this.lastMaxRpm = 0;
      _results = [];
      for (id in angularVelocities) {
        if (!__hasProp.call(angularVelocities, id)) continue;
        currentVelocity = angularVelocities[id];
        turningObject = turningObjects[id];
        if (turningObject instanceof Gear) {
          if (currentVelocity == null) {
            if (!turningObject.isDriver) {
              _results.push(turningObject.updateMotion(0, 1, turningObject.isDriver));
            } else {
              _results.push(void 0);
            }
          } else {
            direction = currentVelocity >= 0 ? 1 : -1;
            radiansPerSecond = Math.abs(currentVelocity);
            turningObject.updateMotion(radiansPerSecond * 60 / (2 * Math.PI), direction, turningObject.isDriver);
            this.lastMaxRpm = Math.max(this.lastMaxRpm, turningObject.rpm);
            _results.push(void 0);
          }
        } else if (turningObject instanceof Chain) {
          if (currentVelocity == null) {
            turningObject.angularVelocity = 0;
          } else {
            turningObject.angularVelocity = currentVelocity;
          }
          _results.push(void 0);
        } else {
          _results.push(void 0);
        }
      }
      return _results;
    };

    Board.prototype.addChainConnections = function(chain) {
      var gearId, _i, _len, _ref, _results;
      _ref = chain.supportingGearIds;
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        gearId = _ref[_i];
        if (gearId in chain.innerGearIds) {
          _results.push(this.addConnection(chain, this.getGearWithId(gearId), ConnectionType.CHAIN_INSIDE));
        } else {
          _results.push(this.addConnection(chain, this.getGearWithId(gearId), ConnectionType.CHAIN_OUTSIDE));
        }
      }
      return _results;
    };

    Board.prototype.updateChainConnections = function(chain) {
      this.removeAllConnections(chain);
      return this.addChainConnections(chain);
    };

    Board.prototype.addChain = function(chain) {
      var oldBoard;
      oldBoard = this.clone();
      this.chains[chain.id] = chain;
      if (chain.tighten(this)) {
        this.chains[chain.id] = chain;
        this.addChainConnections(chain);
      } else {
        this.restore(oldBoard);
        return false;
      }
      if (this.isBoardValid()) {
        this.recalculateGearSpeeds();
        return true;
      } else {
        this.restore(oldBoard);
        return false;
      }
    };

    Board.prototype.removeChain = function(chain) {
      this.removeAllConnections(chain);
      delete this.chains[chain.id];
      return this.recalculateGearSpeeds();
    };

    Board.prototype.getChains = function() {
      return this.chains;
    };

    Board.prototype.getChainsInGroupOnLevel = function(group, level) {
      var chain, id, _ref, _results;
      _ref = this.chains;
      _results = [];
      for (id in _ref) {
        if (!__hasProp.call(_ref, id)) continue;
        chain = _ref[id];
        if ((chain.group === group) && (chain.level === level)) {
          _results.push(chain);
        }
      }
      return _results;
    };

    Board.prototype.getTurningObjects = function() {
      var chain, gear, id, turningObjects, _ref, _ref1;
      turningObjects = {};
      _ref = this.gears;
      for (id in _ref) {
        if (!__hasProp.call(_ref, id)) continue;
        gear = _ref[id];
        turningObjects[id] = gear;
      }
      _ref1 = this.chains;
      for (id in _ref1) {
        if (!__hasProp.call(_ref1, id)) continue;
        chain = _ref1[id];
        turningObjects[id] = chain;
      }
      return turningObjects;
    };

    Board.prototype.clone = function() {
      return {
        gears: Util.clone(this.gears),
        chains: Util.clone(this.chains)
      };
    };

    Board.fromObject = function(obj) {
      var board, chain, gear, id, _ref, _ref1;
      board = new Board();
      _ref = obj.gears;
      for (id in _ref) {
        gear = _ref[id];
        board.gears[id] = Gear.fromObject(gear);
      }
      _ref1 = obj.chains;
      for (id in _ref1) {
        chain = _ref1[id];
        board.chains[id] = Chain.fromObject(chain);
      }
      board.recalculateGearSpeeds();
      return board;
    };

    return Board;

  })();

  window.gearlab.model.Board = Board;

}).call(this);

/*
//@ sourceMappingURL=gearlab_model.map
*/
// Generated by CoffeeScript 1.6.3
(function() {
  "use strict";
  var ArcSegment, Board, Chain, FPS, Gear, GearLab, LineSegment, MIN_GEAR_TEETH, MIN_MOMENTUM, Point, Util,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    __hasProp = {}.hasOwnProperty,
    __slice = [].slice;

  Point = window.gearlab.Point;

  ArcSegment = window.gearlab.ArcSegment;

  LineSegment = window.gearlab.LineSegment;

  Util = window.gearlab.Util;

  Gear = window.gearlab.model.Gear;

  Chain = window.gearlab.model.Chain;

  Board = window.gearlab.model.Board;

  FPS = 60;

  MIN_GEAR_TEETH = 8;

  MIN_MOMENTUM = 0.2;

  GearLab = (function() {
    var AXIS_RADIUS, Action, BUTTON_INFO, MODULE, MovementAction, MovementType;

    MODULE = Util.MODULE;

    AXIS_RADIUS = Util.AXIS_RADIUS;

    BUTTON_INFO = [["playButton", "PlayIcon.png"], ["clearButton", "ClearIcon.png"], ["cloudButton", "CloudIcon.png"], ["helpButton", "HelpIcon.png"]];

    MovementAction = {
      PEN_DOWN: "penDown",
      PEN_UP: "penUp",
      PEN_TAP: "penTap"
    };

    MovementType = {
      STRAIGHT: "straight",
      CIRCLE: "circle",
      LEFT_HALF_CIRCLE: "leftHalfCircle",
      RIGHT_HALF_CIRCLE: "rightHalfCircle"
    };

    Action = {
      DRAGGING: "dragging",
      SETTING_MOMENTUM: "settingMomentum",
      STROKING: "stroking"
    };

    GearLab.prototype.buttons = {};

    GearLab.prototype.loadedButtons = 0;

    GearLab.prototype.areButtonsLoaded = false;

    GearLab.prototype.gearImages = {};

    GearLab.prototype.currentAction = null;

    GearLab.prototype.isPenDown = false;

    GearLab.prototype.stroke = [];

    GearLab.prototype.offset = new Point();

    GearLab.prototype.isPlaying = false;

    GearLab.prototype.message = "";

    GearLab.prototype.messageColor = "black";

    GearLab.prototype.pointerLocation = new Point();

    GearLab.prototype.currentDemoMovement = 0;

    GearLab.prototype.movementCompletion = 0;

    GearLab.prototype.restTimer = 0;

    GearLab.prototype.gearEditorElement = null;

    GearLab.prototype.gearEditorInputs = {};

    GearLab.prototype.pendingGearEditor = null;

    GearLab.prototype.activeEditorGear = null;

    function GearLab(showButtons) {
      if (showButtons == null) {
        showButtons = false;
      }
      this.handleDocumentClick = __bind(this.handleDocumentClick, this);
      this.handleGearModeChange = __bind(this.handleGearModeChange, this);
      this.handleDirectionToggle = __bind(this.handleDirectionToggle, this);
      this.handleGearRpmChange = __bind(this.handleGearRpmChange, this);
      this.handleGearTeethChange = __bind(this.handleGearTeethChange, this);
      this.update = __bind(this.update, this);
      this.updateAndDraw = __bind(this.updateAndDraw, this);
      this.loadButtons();
      this.showButtons = showButtons;
      this.loadDemoPointer();
      this.loadBoard();
      this.canvas = document.getElementById("gearlab_canvas");
      this.canvasOffsetX = this.canvas.getBoundingClientRect().left;
      this.canvasOffsetY = this.canvas.getBoundingClientRect().top;
      this.isDemoPlaying = false;
      this.updateCanvasSize();
      this.addCanvasListeners();
      this.setupGearEditor();
      this.setupBoardIO();
      this.lastUpdateTime = new Date().getTime();
      this.updateAndDraw();
    }

    GearLab.prototype.buttonLoaded = function() {
      this.loadedButtons++;
      if (this.loadedButtons === BUTTON_INFO.length) {
        return this.areButtonsLoaded = true;
      }
    };

    GearLab.prototype.loadButtons = function() {
      var button, file, name, x, y, _i, _len, _ref, _results,
        _this = this;
      x = y = 20;
      _results = [];
      for (_i = 0, _len = BUTTON_INFO.length; _i < _len; _i++) {
        _ref = BUTTON_INFO[_i], name = _ref[0], file = _ref[1];
        button = new Image();
        button.name = name;
        button.onload = function() {
          return _this.buttonLoaded();
        };
        button.src = "img/" + file;
        button.location = new Point(x, y);
        button.padding = 3;
        this.buttons[name] = button;
        _results.push(x += 80);
      }
      return _results;
    };

    GearLab.prototype.loadDemoPointer = function() {
      var image,
        _this = this;
      image = new Image();
      image.onload = function() {
        return _this.pointerImage = image;
      };
      return image.src = "img/hand.png";
    };

    GearLab.prototype.loadBoard = function() {
      var board, boardJSON, error, hash;
      board = (function() {
        if (parent.location.hash.length > 1) {
          try {
            hash = parent.location.hash.substr(1);
            boardJSON = Util.sendGetRequest("boards/" + hash + ".txt");
            return Board.fromObject(JSON.parse(boardJSON));
          } catch (_error) {
            error = _error;
            this.displayMessage("Error: could not load board", "red", 2000);
            return new Board();
          }
        } else {
          return new Board();
        }
      }).call(this);
      return this.replaceBoard(board);
    };

    GearLab.prototype.displayMessage = function(message, color, time) {
      var _this = this;
      if (color == null) {
        color = "black";
      }
      if (time == null) {
        time = 0;
      }
      this.message = message;
      this.messageColor = color;
      if (time > 0) {
        return setTimeout((function() {
          return _this.clearMessage();
        }), time);
      }
    };

    GearLab.prototype.clearMessage = function() {
      return this.message = "";
    };

    GearLab.prototype.shouldShowButtons = function() {
      return this.showButtons || this.isDemoPlaying;
    };

    GearLab.prototype.addCanvasListeners = function() {
      var canvasEventHandler,
        _this = this;
      canvasEventHandler = Hammer(this.canvas, {
        drag_min_distance: 1
      });
      canvasEventHandler.on("touch", (function(e) {
        return _this.forwardPenDownEvent.call(_this, e);
      }));
      canvasEventHandler.on("drag", (function(e) {
        return _this.forwardPenMoveEvent.call(_this, e);
      }));
      return canvasEventHandler.on("release", (function(e) {
        return _this.forwardPenUpEvent.call(_this, e);
      }));
    };

    GearLab.prototype.setupGearEditor = function() {
      this.gearEditorElement = document.getElementById("gear-editor");
      if (!this.gearEditorElement) {
        return;
      }
      this.gearEditorInputs = {
        teeth: document.getElementById("gear-editor-teeth"),
        rpm: document.getElementById("gear-editor-rpm"),
        direction: document.getElementById("gear-editor-direction"),
        driver: document.getElementById("gear-editor-mode-driver"),
        driven: document.getElementById("gear-editor-mode-driven")
      };
      if (this.gearEditorInputs.teeth) {
        this.gearEditorInputs.teeth.addEventListener("change", this.handleGearTeethChange);
      }
      if (this.gearEditorInputs.rpm) {
        this.gearEditorInputs.rpm.addEventListener("change", this.handleGearRpmChange);
      }
      if (this.gearEditorInputs.direction) {
        this.gearEditorInputs.direction.addEventListener("change", this.handleDirectionToggle);
      }
      if (this.gearEditorInputs.driver) {
        this.gearEditorInputs.driver.addEventListener("change", this.handleGearModeChange);
      }
      if (this.gearEditorInputs.driven) {
        this.gearEditorInputs.driven.addEventListener("change", this.handleGearModeChange);
      }
      document.addEventListener("mousedown", this.handleDocumentClick);
      return this.hideGearEditor();
    };

    GearLab.prototype.handleDocumentClick = function(event) {
      if (!this.gearEditorElement || this.gearEditorElement.classList.contains("hidden")) {
        return;
      }
      if (this.gearEditorElement.contains(event.target)) {
        return;
      }
      return this.hideGearEditor();
    };

    GearLab.prototype.showGearEditor = function(gear) {
      var _this = this;
      if (!this.gearEditorElement) {
        return;
      }
      this.activeEditorGear = gear;
      this.refreshGearEditor();
      this.gearEditorElement.classList.remove("hidden");
      return window.requestAnimationFrame(function() {
        return _this.positionGearEditor(gear);
      });
    };

    GearLab.prototype.hideGearEditor = function() {
      if (!this.gearEditorElement) {
        return;
      }
      this.gearEditorElement.classList.add("hidden");
      return this.activeEditorGear = null;
    };

    GearLab.prototype.positionGearEditor = function(gear) {
      var editorRect, left, rect, top;
      if (!(gear && this.gearEditorElement)) {
        return;
      }
      rect = this.canvas.getBoundingClientRect();
      editorRect = this.gearEditorElement.getBoundingClientRect();
      left = rect.left + gear.location.x - 0.5 * editorRect.width;
      top = rect.top + gear.location.y - editorRect.height - 16;
      if (top < 12) {
        top = rect.top + gear.location.y + 20;
      }
      left = Math.max(8, Math.min(left, window.innerWidth - editorRect.width - 8));
      top = Math.max(8, Math.min(top, window.innerHeight - editorRect.height - 8));
      this.gearEditorElement.style.left = left + "px";
      return this.gearEditorElement.style.top = top + "px";
    };

    GearLab.prototype.refreshGearEditor = function() {
      if (!(this.activeEditorGear && this.gearEditorInputs.teeth)) {
        return;
      }
      this.gearEditorInputs.teeth.value = Math.round(this.activeEditorGear.numberOfTeeth);
      if (this.gearEditorInputs.rpm) {
        this.gearEditorInputs.rpm.value = this.formatRpm(this.activeEditorGear.rpm);
      }
      if (this.gearEditorInputs.direction) {
        this.gearEditorInputs.direction.checked = this.activeEditorGear.direction >= 0;
      }
      if (this.gearEditorInputs.driver && this.gearEditorInputs.driven) {
        this.gearEditorInputs.driver.checked = !!this.activeEditorGear.isDriver;
        this.gearEditorInputs.driven.checked = !this.activeEditorGear.isDriver;
      }
      return this.updateGearEditorState();
    };

    GearLab.prototype.updateGearEditorState = function() {
      var isDriver;
      if (!(this.gearEditorInputs && this.gearEditorInputs.driver)) {
        return;
      }
      isDriver = this.gearEditorInputs.driver.checked;
      if (this.gearEditorInputs.rpm) {
        this.gearEditorInputs.rpm.disabled = !isDriver;
      }
      if (this.gearEditorInputs.direction) {
        this.gearEditorInputs.direction.disabled = !isDriver;
      }
      if (!isDriver && this.activeEditorGear && this.gearEditorInputs.rpm) {
        return this.gearEditorInputs.rpm.value = this.formatRpm(this.activeEditorGear.rpm);
      }
    };

    GearLab.prototype.formatRpm = function(value) {
      var rounded;
      if (value == null) {
        value = 0;
      }
      rounded = Math.round(value * 100) / 100;
      return rounded.toFixed(2);
    };

    GearLab.prototype.handleGearTeethChange = function() {
      var gear, newValue;
      gear = this.activeEditorGear;
      if (!(gear && this.gearEditorInputs.teeth)) {
        return;
      }
      newValue = parseInt(this.gearEditorInputs.teeth.value, 10);
      if (isNaN(newValue)) {
        newValue = MIN_GEAR_TEETH;
      }
      if (newValue < MIN_GEAR_TEETH) {
        newValue = MIN_GEAR_TEETH;
      }
      this.gearEditorInputs.teeth.value = newValue;
      if (newValue !== gear.numberOfTeeth) {
        gear.setNumberOfTeeth(newValue);
        if (!(newValue in this.gearImages)) {
          this.addGearImage(gear);
        }
        this.board.recalculateGearSpeeds();
      }
      return this.positionGearEditor(gear);
    };

    GearLab.prototype.handleGearRpmChange = function() {
      var gear, rpm;
      gear = this.activeEditorGear;
      if (!(gear && this.gearEditorInputs.rpm && this.gearEditorInputs.driver && this.gearEditorInputs.driver.checked)) {
        return;
      }
      rpm = parseFloat(this.gearEditorInputs.rpm.value);
      if (isNaN(rpm)) {
        rpm = 0;
      }
      if (rpm < 0) {
        rpm = 0;
      }
      rpm = Math.round(rpm * 100) / 100;
      this.gearEditorInputs.rpm.value = this.formatRpm(rpm);
      gear.updateMotion(rpm, gear.direction, true);
      this.board.recalculateGearSpeeds();
      return this.refreshGearEditor();
    };

    GearLab.prototype.handleDirectionToggle = function() {
      var direction, gear;
      gear = this.activeEditorGear;
      if (!(gear && this.gearEditorInputs.direction && this.gearEditorInputs.driver && this.gearEditorInputs.driver.checked)) {
        return;
      }
      direction = this.gearEditorInputs.direction.checked ? 1 : -1;
      gear.updateMotion(gear.rpm, direction, true);
      this.board.recalculateGearSpeeds();
      return this.refreshGearEditor();
    };

    GearLab.prototype.handleGearModeChange = function() {
      var gear, isDriver;
      gear = this.activeEditorGear;
      if (!gear) {
        return;
      }
      isDriver = this.gearEditorInputs.driver && this.gearEditorInputs.driver.checked;
      gear.updateMotion(gear.rpm, gear.direction, isDriver);
      this.updateGearEditorState();
      this.board.recalculateGearSpeeds();
      return this.refreshGearEditor();
    };

    GearLab.prototype.forwardPenDownEvent = function(event) {
      var x, y;
      event.gesture.preventDefault();
      if (this.isDemoPlaying) {
        return this.stopDemo();
      } else {
        x = event.gesture.center.pageX - this.canvasOffsetX;
        y = event.gesture.center.pageY - this.canvasOffsetY;
        return this.handlePenDown(x, y);
      }
    };

    GearLab.prototype.forwardPenMoveEvent = function(event) {
      var x, y;
      event.gesture.preventDefault();
      if (!this.isDemoPlaying) {
        x = event.gesture.center.pageX - this.canvasOffsetX;
        y = event.gesture.center.pageY - this.canvasOffsetY;
        return this.handlePenMove(x, y);
      }
    };

    GearLab.prototype.forwardPenUpEvent = function(event) {
      if (!this.isDemoPlaying) {
        return this.handlePenUp();
      }
    };

    GearLab.prototype.handlePenDown = function(x, y) {
      var button, gear, point, selection, _ref;
      point = new Point(x, y);
      if (this.isPenDown) {
        return this.handlePenUp();
      } else {
        this.isPlaying = false;
        button = this.getButtonAt(x, y);
        if (button) {
          this.hideGearEditor();
          this.pendingGearEditor = null;
          if (button.name === "playButton") {
            return this.startSimulation();
          } else if (button.name === "clearButton") {
            return this.createBlankBoard();
          } else if (button.name === "cloudButton") {
            return this.downloadBoard();
          } else if (button.name === "helpButton") {
            return this.toggleDemoPlayback();
          }
        } else {
          _ref = this.gearAt(x, y), gear = _ref.gear, selection = _ref.selection;
          if (gear) {
            this.selectedGear = gear;
            if (selection === "center") {
              this.pendingGearEditor = {
                gear: gear,
                selection: selection,
                startPoint: point.clone(),
                moved: false
              };
            } else {
              this.pendingGearEditor = null;
            }
            if (selection === "center") {
              this.currentAction = Action.DRAGGING;
              this.offset = point.minus(this.selectedGear.location);
            } else {
              this.currentAction = Action.SETTING_MOMENTUM;
              this.selectedGear.momentum = 0;
              this.selectedGearMomentum = this.calculateMomentumFromCoords(this.selectedGear, x, y);
              this.hideGearEditor();
            }
          } else {
            this.currentAction = Action.STROKING;
            this.stroke.push(point);
            this.pendingGearEditor = null;
            this.hideGearEditor();
          }
          return this.isPenDown = true;
        }
      }
    };

    GearLab.prototype.handlePenMove = function(x, y) {
      var canPlaceGear, goalLocation, point;
      point = new Point(x, y);
      if (this.isPenDown) {
        if (this.currentAction === Action.DRAGGING) {
          goalLocation = point.minus(this.offset);
          canPlaceGear = this.board.placeGear(this.selectedGear, goalLocation);
          if (canPlaceGear) {
            return this.goalLocationGear = null;
          } else {
            return this.goalLocationGear = new Gear(goalLocation, this.selectedGear.rotation, this.selectedGear.numberOfTeeth, this.selectedGear.id);
          }
        } else if (this.currentAction === Action.SETTING_MOMENTUM) {
          return this.selectedGearMomentum = this.calculateMomentumFromCoords(this.selectedGear, x, y);
        } else if (this.currentAction === Action.STROKING) {
          return this.stroke.push(point);
        }
      }
      if (this.pendingGearEditor && !this.pendingGearEditor.moved) {
        if (this.pendingGearEditor.startPoint.distance(point) > 5) {
          this.pendingGearEditor.moved = true;
        }
      }
    };

    GearLab.prototype.handlePenUp = function() {
      var pendingEditor;
      if (this.isPenDown) {
        pendingEditor = this.pendingGearEditor;
        if (this.currentAction === Action.SETTING_MOMENTUM) {
          if (Math.abs(this.selectedGearMomentum) > MIN_MOMENTUM) {
            this.selectedGear.updateMotion(Math.abs(this.selectedGearMomentum) * 60 / (2 * Math.PI), this.selectedGearMomentum >= 0 ? 1 : -1, true);
          } else {
            this.selectedGear.updateMotion(0, 1, false);
          }
          this.selectedGearMomentum = 0;
          this.board.recalculateGearSpeeds();
        } else if (this.currentAction === Action.DRAGGING) {
          this.board.recalculateGearSpeeds();
        } else if (this.currentAction === Action.STROKING) {
          this.processStroke();
        }
        this.selectedGear = null;
        this.goalLocationGear = null;
        this.isPenDown = false;
        this.currentAction = null;
        this.pendingGearEditor = null;
        if (pendingEditor && !pendingEditor.moved && pendingEditor.selection === "center") {
          return this.showGearEditor(pendingEditor.gear);
        }
        if (!pendingEditor || pendingEditor.selection !== "center") {
          return this.hideGearEditor();
        }
      }
    };

    GearLab.prototype.isButtonAt = function(x, y, button) {
      return x > button.location.x && x < button.location.x + button.width + 2 * button.padding && y > button.location.y && y < button.location.y + button.height + 2 * button.padding;
    };

    GearLab.prototype.getButtonAt = function(x, y) {
      var button, buttonName, _ref;
      if (!this.shouldShowButtons()) {
        return null;
      }
      _ref = this.buttons;
      for (buttonName in _ref) {
        if (!__hasProp.call(_ref, buttonName)) continue;
        button = _ref[buttonName];
        if (this.isButtonAt(x, y, button)) {
          return button;
        }
      }
      return null;
    };

    GearLab.prototype.gearAt = function(x, y) {
      var gear, point;
      point = new Point(x, y);
      gear = this.board.getGearAt(point);
      if (!gear) {
        return {
          gear: null
        };
      } else if (gear.location.distance(point) < 0.5 * gear.outerRadius) {
        return {
          gear: gear,
          selection: "center"
        };
      } else {
        return {
          gear: gear,
          selection: "edge"
        };
      }
    };

    GearLab.prototype.normalizeStroke = function(stroke) {
      var MIN_POINT_DISTANCE, normalizedStroke, p1, p2, strokeTail, _i, _len;
      MIN_POINT_DISTANCE = 10;
      normalizedStroke = [];
      if (stroke.length > 0) {
        p1 = stroke[0], strokeTail = 2 <= stroke.length ? __slice.call(stroke, 1) : [];
        normalizedStroke.push(p1);
        for (_i = 0, _len = strokeTail.length; _i < _len; _i++) {
          p2 = strokeTail[_i];
          if (p1.distance(p2) > MIN_POINT_DISTANCE) {
            normalizedStroke.push(p2);
            p1 = p2;
          }
        }
      }
      return normalizedStroke;
    };

    GearLab.prototype.createGearFromStroke = function(stroke) {
      var area, doubleArea, height, i, idealTrueAreaRatio, maxX, maxY, minX, minY, numberOfPoints, p, p1, p2, radius, sumX, sumY, t, width, x, y, _i, _j, _len, _len1;
      numberOfPoints = stroke.length;
      if (numberOfPoints > 0) {
        sumX = 0;
        sumY = 0;
        minX = Number.MAX_VALUE;
        maxX = Number.MIN_VALUE;
        minY = Number.MAX_VALUE;
        maxY = Number.MIN_VALUE;
        for (_i = 0, _len = stroke.length; _i < _len; _i++) {
          p = stroke[_i];
          sumX += p.x;
          sumY += p.y;
          minX = Math.min(minX, p.x);
          maxX = Math.max(maxX, p.x);
          minY = Math.min(minY, p.y);
          maxY = Math.max(maxY, p.y);
        }
        width = maxX - minX;
        height = maxY - minY;
        t = Math.floor(0.5 * (width + height) / MODULE);
        doubleArea = 0;
        for (i = _j = 0, _len1 = stroke.length; _j < _len1; i = ++_j) {
          p1 = stroke[i];
          p2 = stroke[(i + 1) % numberOfPoints];
          doubleArea += p1.cross(p2);
        }
        area = Math.abs(doubleArea) / 2;
        radius = 0.25 * ((maxX - minX) + (maxY - minY));
        idealTrueAreaRatio = (Math.PI * Math.pow(radius, 2)) / area;
        if (idealTrueAreaRatio > 0.80 && idealTrueAreaRatio < 1.20 && t > MIN_GEAR_TEETH) {
          x = sumX / numberOfPoints;
          y = sumY / numberOfPoints;
          return new Gear(new Point(x, y), 0, t);
        }
      }
      return null;
    };

    GearLab.prototype.removeStrokedGears = function(stroke) {
      var gear, id, _ref, _results;
      _ref = this.board.getTopLevelGears();
      _results = [];
      for (id in _ref) {
        if (!__hasProp.call(_ref, id)) continue;
        gear = _ref[id];
        if (Util.pointPathDistance(gear.location, stroke, false) < gear.innerRadius) {
          if (this.activeEditorGear === gear) {
            this.hideGearEditor();
          }
          _results.push(this.board.removeGear(gear));
        } else {
          _results.push(void 0);
        }
      }
      return _results;
    };

    GearLab.prototype.gearImageLoaded = function(numberOfTeeth, image) {
      return this.gearImages[numberOfTeeth] = image;
    };

    GearLab.prototype.addGearImage = function(gear) {
      var ctx, gearCanvas, gearCopy, image, size,
        _this = this;
      gearCanvas = document.createElement("canvas");
      size = 2 * (gear.outerRadius + MODULE);
      gearCanvas.height = size;
      gearCanvas.width = size;
      ctx = gearCanvas.getContext("2d");
      gearCopy = new Gear(new Point(0.5 * size, 0.5 * size), 0, gear.numberOfTeeth, gear.id);
      this.drawGear(ctx, gearCopy);
      image = new Image();
      image.onload = function() {
        return _this.gearImageLoaded(gear.numberOfTeeth, image);
      };
      return image.src = gearCanvas.toDataURL("image/png");
    };

    GearLab.prototype.isChainStroked = function(stroke) {
      var chain, id, _ref;
      _ref = this.board.getChains();
      for (id in _ref) {
        if (!__hasProp.call(_ref, id)) continue;
        chain = _ref[id];
        if (chain.intersectsPath(stroke)) {
          return true;
        }
      }
      return false;
    };

    GearLab.prototype.removeStrokedChains = function(stroke) {
      var chain, id, _ref, _results;
      _ref = this.board.getChains();
      _results = [];
      for (id in _ref) {
        if (!__hasProp.call(_ref, id)) continue;
        chain = _ref[id];
        if (chain.intersectsPath(stroke)) {
          _results.push(this.board.removeChain(chain));
        } else {
          _results.push(void 0);
        }
      }
      return _results;
    };

    GearLab.prototype.processStroke = function() {
      var chain, gear, normalizedStroke;
      normalizedStroke = this.normalizeStroke(this.stroke);
      if (normalizedStroke.length >= 3) {
        if (Util.findGearsInsidePolygon(normalizedStroke, this.board.getGears()).length > 0) {
          chain = new Chain(normalizedStroke);
          this.board.addChain(chain);
        } else {
          gear = this.createGearFromStroke(normalizedStroke);
          if (gear != null) {
            if (this.board.addGear(gear) && !(gear.numberOfTeeth in this.gearImages)) {
              this.addGearImage(gear);
            }
          } else if (this.isChainStroked(normalizedStroke)) {
            this.removeStrokedChains(normalizedStroke);
          } else {
            this.removeStrokedGears(normalizedStroke);
          }
        }
      }
      return this.stroke = [];
    };

    GearLab.prototype.calculateMomentumFromCoords = function(gear, x, y) {
      var angle, angleFromTop;
      angle = Math.atan2(y - gear.location.y, x - gear.location.x);
      angleFromTop = angle + 0.5 * Math.PI;
      if (angleFromTop < Math.PI) {
        return angleFromTop;
      } else {
        return angleFromTop - 2 * Math.PI;
      }
    };

    GearLab.prototype.updateAndDraw = function() {
      var _this = this;
      return setTimeout((function() {
        requestAnimationFrame(_this.updateAndDraw);
        _this.update();
        return _this.draw();
      }), 1000 / FPS);
    };

    GearLab.prototype.update = function() {
      var delta, updateTime;
      updateTime = new Date().getTime();
      delta = updateTime - this.lastUpdateTime;
      if (this.isPlaying) {
        this.board.rotateAllTurningObjects(delta);
      }
      if (this.isDemoPlaying) {
        this.updateDemo(delta);
      }
      return this.lastUpdateTime = updateTime;
    };

    GearLab.prototype.drawGear = function(ctx, gear, color) {
      var angleStep, gearImage, i, innerPoints, numberOfTeeth, outerPoints, r, rotation, x, y, _i, _j, _k, _ref, _ref1;
      if (color == null) {
        color = "black";
      }
      _ref = gear.location, x = _ref.x, y = _ref.y;
      rotation = gear.rotation;
      numberOfTeeth = gear.numberOfTeeth;
      gearImage = this.gearImages[gear.numberOfTeeth];
      if (color === "black" && (gearImage != null)) {
        gearImage = this.gearImages[gear.numberOfTeeth];
        ctx.save();
        ctx.translate(x, y);
        ctx.rotate(rotation);
        ctx.drawImage(gearImage, -0.5 * gearImage.width, -0.5 * gearImage.height);
        ctx.restore();
        return;
      }
      angleStep = 2 * Math.PI / numberOfTeeth;
      innerPoints = [];
      outerPoints = [];
      for (i = _i = 0; 0 <= numberOfTeeth ? _i < numberOfTeeth : _i > numberOfTeeth; i = 0 <= numberOfTeeth ? ++_i : --_i) {
        for (r = _j = 0; _j < 4; r = ++_j) {
          if (r === 0 || r === 3) {
            innerPoints.push(Point.polar((i + 0.25 * r) * angleStep, gear.innerRadius));
          } else {
            outerPoints.push(Point.polar((i + 0.25 * r) * angleStep, gear.outerRadius));
          }
        }
      }
      ctx.save();
      ctx.fillStyle = "rgba(255, 255, 255, 0.8)";
      ctx.strokeStyle = color;
      ctx.lineWidth = 2;
      ctx.translate(x, y);
      ctx.rotate(rotation);
      ctx.beginPath();
      ctx.moveTo(gear.innerRadius, 0);
      for (i = _k = 0, _ref1 = numberOfTeeth * 2; 0 <= _ref1 ? _k < _ref1 : _k > _ref1; i = 0 <= _ref1 ? ++_k : --_k) {
        if (i % 2 === 0) {
          ctx.lineTo(innerPoints[i].x, innerPoints[i].y);
          ctx.lineTo(outerPoints[i].x, outerPoints[i].y);
        } else {
          ctx.lineTo(outerPoints[i].x, outerPoints[i].y);
          ctx.lineTo(innerPoints[i].x, innerPoints[i].y);
        }
      }
      ctx.closePath();
      ctx.fill();
      ctx.stroke();
      ctx.beginPath();
      ctx.moveTo(0, 0);
      ctx.arc(0, 0, AXIS_RADIUS, 0, 2 * Math.PI, true);
      ctx.closePath();
      ctx.stroke();
      ctx.beginPath();
      ctx.strokeStyle = "#e53935";
      ctx.lineWidth = 3;
      ctx.moveTo(0, 0);
      ctx.lineTo(gear.outerRadius, 0);
      ctx.stroke();
      return ctx.restore();
    };

    GearLab.prototype.drawButton = function(ctx, button) {
      var height, padding, radius, width, x, y, _ref;
      _ref = button.location, x = _ref.x, y = _ref.y;
      padding = button.padding;
      ctx.save();
      ctx.translate(x, y);
      ctx.beginPath();
      radius = 10;
      width = button.width + 2 * padding;
      height = button.height + 2 * padding;
      ctx.moveTo(radius, 0);
      ctx.lineTo(width - radius, 0);
      ctx.quadraticCurveTo(width, 0, width, radius);
      ctx.lineTo(width, height - radius);
      ctx.quadraticCurveTo(width, height, width - radius, height);
      ctx.lineTo(radius, height);
      ctx.quadraticCurveTo(0, height, 0, height - radius);
      ctx.lineTo(0, radius);
      ctx.quadraticCurveTo(0, 0, radius, 0);
      if (button.name === this.selectedButton) {
        ctx.fillStyle = "rgba(50, 150, 255, 0.8)";
      } else {
        ctx.fillStyle = "rgba(255, 255, 255, 0.8)";
      }
      ctx.fill();
      ctx.lineWidth = 1;
      ctx.strokeStyle = "black";
      ctx.stroke();
      ctx.drawImage(button, padding, padding);
      return ctx.restore();
    };

    GearLab.prototype.drawMomentum = function(ctx, gear, momentum, color) {
      var angle, head, headX, headY, length, p1, p2, pitchRadius, sign, top;
      if (color == null) {
        color = "red";
      }
      pitchRadius = gear.pitchRadius;
      top = new Point(gear.location.x, gear.location.y - pitchRadius);
      ctx.save();
      ctx.lineWidth = 5;
      ctx.lineCap = "round";
      ctx.strokeStyle = color;
      ctx.translate(top.x, top.y);
      ctx.beginPath();
      ctx.arc(0, pitchRadius, pitchRadius, -0.5 * Math.PI, momentum - 0.5 * Math.PI, momentum < 0);
      ctx.stroke();
      length = 15;
      angle = 0.2 * Math.PI;
      headX = -Math.cos(momentum + 0.5 * Math.PI) * pitchRadius;
      headY = pitchRadius - Math.sin(momentum + 0.5 * Math.PI) * pitchRadius;
      head = new Point(headX, headY);
      sign = Util.sign(momentum);
      p1 = head.minus(Point.polar(momentum + angle, sign * length));
      ctx.beginPath();
      ctx.moveTo(headX, headY);
      ctx.lineTo(p1.x, p1.y);
      ctx.stroke();
      p2 = head.minus(Point.polar(momentum - angle, sign * length));
      ctx.beginPath();
      ctx.moveTo(headX, headY);
      ctx.lineTo(p2.x, p2.y);
      ctx.stroke();
      return ctx.restore();
    };

    GearLab.prototype.drawChain = function(ctx, chain) {
      var isCounterClockwise, point, segment, _i, _j, _len, _len1, _ref, _ref1;
      ctx.save();
      ctx.lineWidth = Chain.WIDTH;
      ctx.lineCap = "round";
      ctx.strokeStyle = "rgb(0, 0, 255)";
      ctx.moveTo(chain.segments[0].start.x, chain.segments[0].start.y);
      _ref = chain.segments;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        segment = _ref[_i];
        if (segment instanceof ArcSegment) {
          isCounterClockwise = segment.direction === Util.Direction.COUNTER_CLOCKWISE;
          ctx.beginPath();
          ctx.arc(segment.center.x, segment.center.y, segment.radius, segment.startAngle, segment.endAngle, isCounterClockwise);
          ctx.stroke();
        } else {
          ctx.beginPath();
          ctx.moveTo(segment.start.x, segment.start.y);
          ctx.lineTo(segment.end.x, segment.end.y);
          ctx.stroke();
        }
      }
      ctx.fillStyle = "white";
      _ref1 = chain.findPointsOnChain(25);
      for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
        point = _ref1[_j];
        ctx.beginPath();
        ctx.arc(point.x, point.y, 3, 0, 2 * Math.PI, true);
        ctx.fill();
      }
      return ctx.restore();
    };

    GearLab.prototype.drawDemoPointer = function(ctx, location) {
      return ctx.drawImage(this.pointerImage, location.x - 0.5 * this.pointerImage.width, location.y);
    };

    GearLab.prototype.draw = function() {
      var arrow, arrowsToDraw, buttonName, chain, ctx, gear, i, momentum, shouldDrawChainsAndArrows, sortedGears, _i, _j, _k, _l, _len, _len1, _ref, _ref1, _ref2, _ref3;
      if (this.canvas.getContext != null) {
        this.updateCanvasSize();
        ctx = this.canvas.getContext("2d");
        ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
        sortedGears = this.board.getGearsSortedByGroupAndLevel();
        arrowsToDraw = [];
        for (i = _i = 0, _ref = sortedGears.length; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
          gear = sortedGears[i];
          momentum = gear.momentum;
          if (gear === this.selectedGear && this.goalLocationGear) {
            this.drawGear(ctx, gear, "grey");
            if (momentum) {
              arrowsToDraw.push([gear, momentum, "grey"]);
            }
          } else {
            this.drawGear(ctx, gear);
            if (momentum) {
              arrowsToDraw.push([gear, momentum, "red"]);
            }
          }
          shouldDrawChainsAndArrows = (i === sortedGears.length - 1) || (this.board.getLevelScore(gear) !== this.board.getLevelScore(sortedGears[i + 1]));
          if (shouldDrawChainsAndArrows) {
            _ref1 = this.board.getChainsInGroupOnLevel(gear.group, gear.level);
            for (_j = 0, _len = _ref1.length; _j < _len; _j++) {
              chain = _ref1[_j];
              this.drawChain(ctx, chain);
            }
            for (_k = 0, _len1 = arrowsToDraw.length; _k < _len1; _k++) {
              arrow = arrowsToDraw[_k];
              this.drawMomentum(ctx, arrow[0], arrow[1], arrow[2]);
            }
            arrowsToDraw = [];
          }
        }
        if (this.goalLocationGear) {
          this.drawGear(ctx, this.goalLocationGear, "red");
        }
        if ((this.selectedGear != null) && this.selectedGearMomentum) {
          this.drawMomentum(ctx, this.selectedGear, this.selectedGearMomentum);
        }
        if (this.stroke.length > 0) {
          ctx.save();
          ctx.strokeStyle = "black";
          ctx.lineWidth = 2;
          ctx.beginPath();
          ctx.moveTo(this.stroke[0].x, this.stroke[0].y);
          for (i = _l = 1, _ref2 = this.stroke.length; 1 <= _ref2 ? _l < _ref2 : _l > _ref2; i = 1 <= _ref2 ? ++_l : --_l) {
            ctx.lineTo(this.stroke[i].x, this.stroke[i].y);
          }
          ctx.stroke();
          ctx.restore();
        }
        if (this.areButtonsLoaded && this.showButtons) {
          _ref3 = this.buttons;
          for (buttonName in _ref3) {
            if (!__hasProp.call(_ref3, buttonName)) continue;
            this.drawButton(ctx, this.buttons[buttonName]);
          }
        }
        if (this.message.length > 0) {
          ctx.save();
          ctx.fillStyle = this.messageColor;
          ctx.font = "bold 20px Arial";
          ctx.fillText(this.message, 20, 120);
          ctx.restore();
        }
        if (this.isDemoPlaying && this.pointerImage) {
          return this.drawDemoPointer(ctx, this.pointerLocation);
        }
      }
    };

    GearLab.prototype.updateCanvasSize = function() {
      this.canvas.width = this.canvas.parentElement.getBoundingClientRect().width;
      this.canvas.height = this.canvas.parentElement.getBoundingClientRect().height;
      this.buttons["clearButton"].location.x = Math.max(this.canvas.width - 260, this.buttons["playButton"].location.x + 80);
      this.buttons["cloudButton"].location.x = this.buttons["clearButton"].location.x + 80;
      this.buttons["helpButton"].location.x = this.buttons["cloudButton"].location.x + 80;
      if (this.activeEditorGear) {
        this.positionGearEditor(this.activeEditorGear);
      }
      this.canvasOffsetX = this.canvas.getBoundingClientRect().left;
      this.canvasOffsetY = this.canvas.getBoundingClientRect().top;
      return;
    };

    GearLab.prototype.loadDemoMovements = function() {
      return this.demoMovements = [
        {
          from: this.getButtonCenter("helpButton"),
          to: new Point(400, 200),
          type: MovementType.STRAIGHT,
          duration: 1500
        }, {
          atStart: MovementAction.PEN_DOWN,
          atEnd: MovementAction.PEN_UP,
          type: MovementType.CIRCLE,
          radius: 100,
          duration: 1500
        }, {
          to: new Point(600, 200),
          type: MovementType.STRAIGHT,
          duration: 1000
        }, {
          atStart: MovementAction.PEN_DOWN,
          atEnd: MovementAction.PEN_UP,
          type: MovementType.CIRCLE,
          radius: 40,
          duration: 1000
        }, {
          to: new Point(600, 240),
          type: MovementType.STRAIGHT,
          duration: 500
        }, {
          to: new Point(400, 300),
          atStart: MovementAction.PEN_DOWN,
          atEnd: MovementAction.PEN_UP,
          type: MovementType.STRAIGHT,
          duration: 1500
        }, {
          to: new Point(200, 180),
          type: MovementType.STRAIGHT,
          duration: 1000
        }, {
          atStart: MovementAction.PEN_DOWN,
          atEnd: MovementAction.PEN_UP,
          type: MovementType.CIRCLE,
          radius: 90,
          duration: 1000
        }, {
          to: new Point(200, 260),
          type: MovementType.STRAIGHT,
          duration: 500
        }, {
          to: new Point(280, 260),
          atStart: MovementAction.PEN_DOWN,
          atEnd: MovementAction.PEN_UP,
          type: MovementType.STRAIGHT,
          duration: 1500
        }, {
          to: new Point(650, 220),
          type: MovementType.STRAIGHT,
          duration: 1500
        }, {
          atStart: MovementAction.PEN_DOWN,
          atEnd: MovementAction.PEN_UP,
          type: MovementType.CIRCLE,
          radius: 80,
          duration: 1000
        }, {
          to: new Point(380, 150),
          type: MovementType.STRAIGHT,
          duration: 1500
        }, {
          atStart: MovementAction.PEN_DOWN,
          type: MovementType.LEFT_HALF_CIRCLE,
          radius: 140,
          duration: 1500,
          pause: 0
        }, {
          to: new Point(700, 400),
          type: MovementType.STRAIGHT,
          duration: 1000,
          pause: 0
        }, {
          type: MovementType.RIGHT_HALF_CIRCLE,
          radius: 110,
          duration: 1000,
          pause: 0
        }, {
          to: new Point(380, 150),
          atEnd: MovementAction.PEN_UP,
          type: MovementType.STRAIGHT,
          duration: 1000
        }, {
          to: new Point(285, 180),
          type: MovementType.STRAIGHT,
          duration: 1500
        }, {
          to: new Point(250, 190),
          atStart: MovementAction.PEN_DOWN,
          atEnd: MovementAction.PEN_UP,
          type: MovementType.STRAIGHT,
          duration: 1000
        }, {
          to: this.getButtonCenter("playButton"),
          atEnd: MovementAction.PEN_TAP,
          type: MovementType.STRAIGHT,
          duration: 1000
        }, {
          to: new Point(525, 250),
          type: MovementType.STRAIGHT,
          duration: 3000
        }, {
          to: new Point(625, 150),
          atStart: MovementAction.PEN_DOWN,
          atEnd: MovementAction.PEN_UP,
          type: MovementType.STRAIGHT,
          duration: 1000
        }, {
          to: new Point(120, 250),
          type: MovementType.STRAIGHT,
          duration: 1000
        }, {
          to: new Point(750, 300),
          atStart: MovementAction.PEN_DOWN,
          atEnd: MovementAction.PEN_UP,
          type: MovementType.STRAIGHT,
          duration: 1500
        }, {
          to: new Point(525, 200),
          type: MovementType.STRAIGHT,
          duration: 1000
        }, {
          to: new Point(300, 400),
          atStart: MovementAction.PEN_DOWN,
          atEnd: MovementAction.PEN_UP,
          type: MovementType.STRAIGHT,
          duration: 1500
        }
      ];
    };

    GearLab.prototype.getButtonCenter = function(buttonName) {
      var button, buttonCorner;
      button = this.buttons[buttonName];
      buttonCorner = new Point(button.location.x, button.location.y);
      return buttonCorner.plus(new Point(0.5 * button.width + button.padding, 0.5 * button.height + button.padding));
    };

    GearLab.prototype.updateDemo = function(delta) {
      var movement;
      if (this.restTimer > 0) {
        this.restTimer = Math.max(this.restTimer - delta, 0);
        return;
      } else if (this.currentDemoMovement === this.demoMovements.length) {
        this.stopDemo();
        return;
      }
      movement = this.demoMovements[this.currentDemoMovement];
      if (this.movementCompletion === 0) {
        if (movement.from == null) {
          movement.from = this.pointerLocation;
        }
        if (movement.pause == null) {
          movement.pause = 500;
        }
        this.pointerLocation = movement.from.clone();
        if (movement.atStart === MovementAction.PEN_DOWN) {
          this.handlePenDown(this.pointerLocation.x, this.pointerLocation.y);
        }
      }
      if (this.movementCompletion < 1) {
        this.movementCompletion = Math.min(1, this.movementCompletion + delta / movement.duration);
        this.updatePointerLocation(movement, this.movementCompletion);
        this.handlePenMove(this.pointerLocation.x, this.pointerLocation.y);
      }
      if (this.movementCompletion === 1) {
        if (movement.atEnd === MovementAction.PEN_TAP) {
          this.handlePenDown(this.pointerLocation.x, this.pointerLocation.y);
          this.handlePenUp();
        } else if (movement.atEnd === MovementAction.PEN_UP) {
          this.handlePenUp();
        }
        this.restTimer = movement.pause;
        this.movementCompletion = 0;
        return this.currentDemoMovement++;
      }
    };

    GearLab.prototype.updatePointerLocation = function(movement, movementCompletion) {
      var angle, center, delta;
      if (movement.type === MovementType.STRAIGHT) {
        delta = movement.to.minus(movement.from);
        return this.pointerLocation = movement.from.plus(delta.times(movementCompletion));
      } else if (movement.type === MovementType.CIRCLE) {
        center = new Point(movement.from.x, movement.from.y + movement.radius);
        return this.pointerLocation = center.plus(Point.polar(Math.PI - (movementCompletion - 0.25) * 2 * Math.PI, movement.radius));
      } else if (movement.type === MovementType.LEFT_HALF_CIRCLE) {
        center = new Point(movement.from.x, movement.from.y + movement.radius);
        angle = 1.5 * Math.PI - movementCompletion * Math.PI;
        return this.pointerLocation = center.plus(Point.polar(angle, movement.radius));
      } else if (movement.type === MovementType.RIGHT_HALF_CIRCLE) {
        center = new Point(movement.from.x, movement.from.y - movement.radius);
        angle = 0.5 * Math.PI - movementCompletion * Math.PI;
        return this.pointerLocation = center.plus(Point.polar(angle, movement.radius));
      }
    };

    GearLab.prototype.startSimulation = function() {
      if (this.isDemoPlaying) {
        this.stopDemo();
      }
      this.isPlaying = true;
      if (this.board.getGearList().every(function(g) {
        return g.momentum === 0;
      })) {
        return this.displayMessage("Add some arrows!", "black", 2000);
      } else {
        return this.displayMessage("Simulaci en marxa", "black", 2000);
      }
    };

    GearLab.prototype.createBlankBoard = function() {
      if (this.isDemoPlaying) {
        this.stopDemo();
      }
      this.isPlaying = false;
      parent.location.hash = "";
      this.board.clear();
      return this.displayMessage("S'ha creat un board en blanc", "black", 3000);
    };

    GearLab.prototype.toggleDemoPlayback = function() {
      if (this.isDemoPlaying) {
        this.stopDemo();
        return this.displayMessage("Demo aturada", "black", 2000);
      } else {
        this.isPlaying = false;
        return this.playDemo();
      }
    };

    GearLab.prototype.playDemo = function() {
      this.loadDemoMovements();
      this.boardBackup = this.board.clone();
      this.board.clear();
      this.currentDemoMovement = 0;
      this.movementCompletion = 0;
      this.isDemoPlaying = true;
      return this.displayMessage("click anywhere to stop the demo");
    };

    GearLab.prototype.stopDemo = function() {
      this.isDemoPlaying = false;
      this.restTimer = 0;
      this.stroke = [];
      this.selectedGear = null;
      this.selectedIcon = "gearIcon";
      this.board.restoreAfterDemo(this.boardBackup);
      return this.clearMessage();
    };

    GearLab.prototype.boardUploaded = function(event) {
      parent.location.hash = event.target.responseText.trim();
      return this.displayMessage("Board saved. Share it by copying the text in your address bar.", "black", 4000);
    };

    GearLab.prototype.uploadBoard = function() {
      return this.downloadBoard();
    };

    GearLab.prototype.setupBoardIO = function() {
      var demoButton, fileInput, importButton, newButton, playButton, saveButton,
        _this = this;
      saveButton = document.getElementById("download-board");
      importButton = document.getElementById("import-board");
      fileInput = document.getElementById("board-file-input");
      newButton = document.getElementById("new-board");
      playButton = document.getElementById("start-simulation");
      demoButton = document.getElementById("start-demo");
      if (!(saveButton && importButton && fileInput && newButton && playButton && demoButton)) {
        return;
      }
      newButton.addEventListener("click", function() {
        return _this.createBlankBoard();
      });
      saveButton.addEventListener("click", function() {
        return _this.downloadBoard();
      });
      importButton.addEventListener("click", function() {
        _this.isPlaying = false;
        if (_this.isDemoPlaying) {
          _this.stopDemo();
        }
        fileInput.value = "";
        return fileInput.click();
      });
      playButton.addEventListener("click", function() {
        return _this.startSimulation();
      });
      demoButton.addEventListener("click", function() {
        return _this.toggleDemoPlayback();
      });
      return fileInput.addEventListener("change", function(event) {
        return _this.handleBoardFileSelected(event);
      });
    };

    GearLab.prototype.replaceBoard = function(board) {
      var gear, id, _ref;
      this.board = board;
      this.board.recalculateGearSpeeds();
      this.selectedGear = null;
      this.goalLocationGear = null;
      this.stroke = [];
      this.gearImages = {};
      _ref = this.board.getGears();
      for (id in _ref) {
        if (!__hasProp.call(_ref, id)) continue;
        gear = _ref[id];
        this.addGearImage(gear);
      }
      return this.update();
    };

    GearLab.prototype.handleBoardFileSelected = function(event) {
      var file, files,
        _this = this;
      files = event.target.files;
      if (!(files && files.length > 0)) {
        return;
      }
      file = files[0];
      return this.readBoardFile(file).then(function(boardJSON) {
        var boardObject;
        boardObject = Board.fromObject(JSON.parse(boardJSON));
        parent.location.hash = "";
        _this.isPlaying = false;
        if (_this.isDemoPlaying) {
          _this.stopDemo();
        }
        _this.replaceBoard(boardObject);
        return _this.displayMessage("Board carregada correctament", "black", 3000);
      })["catch"](function(error) {
        console.error(error);
        return _this.displayMessage("No s'ha pogut carregar el fitxer", "red", 4000);
      });
    };

    GearLab.prototype.readBoardFile = function(file) {
      var _this = this;
      return new Promise(function(resolve, reject) {
        var reader;
        reader = new FileReader();
        reader.onload = function(loadEvent) {
          var password;
          password = window.prompt("Introdueix la contrasenya utilitzada per desar el board:");
          if (password === null) {
            return reject(new Error("Import cancelled"));
          }
          if (password.length === 0) {
            return reject(new Error("Empty password"));
          }
          return _this.decryptBoardData(loadEvent.target.result, password).then(function(decoded) {
            return resolve(decoded);
          })["catch"](function(error) {
            return reject(error);
          });
        };
        reader.onerror = function() {
          return reject(new Error("File read error"));
        };
        return reader.readAsArrayBuffer(file);
      });
    };

    GearLab.prototype.downloadBoard = function() {
      var boardJSON, password,
        _this = this;
      boardJSON = JSON.stringify(this.board);
      password = window.prompt("Introdueix una contrasenya per protegir el fitxer:");
      if (password === null) {
        return;
      }
      if (password.length === 0) {
        this.displayMessage("Cal una contrasenya per desar el board", "red", 3000);
        return;
      }
      return this.encryptBoardData(boardJSON, password).then(function(buffer) {
        var blob, link;
        blob = new Blob([buffer], {
          type: "application/octet-stream"
        });
        link = document.createElement("a");
        link.href = window.URL.createObjectURL(blob);
        link.download = "gearlab-board.glb";
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
        return _this.displayMessage("Board descarregat correctament", "black", 3000);
      })["catch"](function(error) {
        console.error(error);
        return _this.displayMessage("No s'ha pogut desar el board", "red", 4000);
      });
    };

    GearLab.prototype.encryptBoardData = function(plainText, password) {
      var data, encoder, iv, salt;
      if (!(window.crypto && window.crypto.subtle)) {
        return Promise.reject(new Error("WebCrypto API not available"));
      }
      encoder = new TextEncoder();
      data = encoder.encode(plainText);
      salt = window.crypto.getRandomValues(new Uint8Array(16));
      iv = window.crypto.getRandomValues(new Uint8Array(12));
      return window.crypto.subtle.importKey("raw", encoder.encode(password), {
        name: "PBKDF2"
      }, false, ["deriveKey"]).then(function(keyMaterial) {
        return window.crypto.subtle.deriveKey({
          name: "PBKDF2",
          salt: salt,
          iterations: 100000,
          hash: "SHA-256"
        }, keyMaterial, {
          name: "AES-GCM",
          length: 256
        }, false, ["encrypt"]);
      }).then(function(key) {
        return window.crypto.subtle.encrypt({
          name: "AES-GCM",
          iv: iv
        }, key, data);
      }).then(function(cipherBuffer) {
        var combined;
        combined = new Uint8Array(salt.length + iv.length + cipherBuffer.byteLength);
        combined.set(salt, 0);
        combined.set(iv, salt.length);
        combined.set(new Uint8Array(cipherBuffer), salt.length + iv.length);
        return combined.buffer;
      });
    };

    GearLab.prototype.decryptBoardData = function(buffer, password) {
      var ciphertext, decoder, iv, passwordBytes, salt;
      if (!(window.crypto && window.crypto.subtle)) {
        return Promise.reject(new Error("WebCrypto API not available"));
      }
      if (!(buffer && buffer.byteLength > 28)) {
        return Promise.reject(new Error("Invalid file"));
      }
      salt = new Uint8Array(buffer.slice(0, 16));
      iv = new Uint8Array(buffer.slice(16, 28));
      ciphertext = buffer.slice(28);
      passwordBytes = new TextEncoder().encode(password);
      decoder = new TextDecoder();
      return window.crypto.subtle.importKey("raw", passwordBytes, {
        name: "PBKDF2"
      }, false, ["deriveKey"]).then(function(keyMaterial) {
        return window.crypto.subtle.deriveKey({
          name: "PBKDF2",
          salt: salt,
          iterations: 100000,
          hash: "SHA-256"
        }, keyMaterial, {
          name: "AES-GCM",
          length: 256
        }, false, ["decrypt"]);
      }).then(function(key) {
        return window.crypto.subtle.decrypt({
          name: "AES-GCM",
          iv: iv
        }, key, ciphertext);
      }).then(function(plainBuffer) {
        return decoder.decode(plainBuffer);
      });
    };

    return GearLab;

  })();

  window.gearlab.GearLab = GearLab;

}).call(this);

/*
//@ sourceMappingURL=gearlab_main.map
*/
